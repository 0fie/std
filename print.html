<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Standard Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="tutorials/hello-world/index.html"><strong aria-hidden="true">1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="tutorials/hello-moon/index.html"><strong aria-hidden="true">2.</strong> Hello Moon</a></li><li class="chapter-item expanded affix "><li class="part-title">How-To Guides</li><li class="chapter-item expanded "><a href="guides/growing-cells.html"><strong aria-hidden="true">3.</strong> Growing Cells</a></li><li class="chapter-item expanded "><a href="guides/incl.html"><strong aria-hidden="true">4.</strong> Include Filter</a></li><li class="chapter-item expanded "><a href="guides/envrc.html"><strong aria-hidden="true">5.</strong> Setup .envrc</a></li><li class="chapter-item expanded affix "><li class="part-title">Explanation</li><li class="chapter-item expanded "><a href="explain/why-nix.html"><strong aria-hidden="true">6.</strong> Why nix?</a></li><li class="chapter-item expanded "><a href="explain/why-std.html"><strong aria-hidden="true">7.</strong> Why std?</a></li><li class="chapter-item expanded "><a href="explain/architecture-decision-records/index.html"><strong aria-hidden="true">8.</strong> Architecture Decisions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explain/architecture-decision-records/0003-drop-as-nix-cli-epiphyte-flag.html"><strong aria-hidden="true">8.1.</strong> 0001 Drop as-nix-cli-epiphyte flag</a></li><li class="chapter-item expanded "><a href="explain/architecture-decision-records/0002-wire-up-documentation-instrumentation.html"><strong aria-hidden="true">8.2.</strong> 0002 Wire Up Documentation Instrumentation</a></li><li class="chapter-item expanded "><a href="explain/architecture-decision-records/0001-increase-repo-discoverability-with-a-tui.html"><strong aria-hidden="true">8.3.</strong> 0003 Increase Repo Discoverability With a Tui</a></li><li class="chapter-item expanded "><a href="explain/architecture-decision-records/0004-add-nixago-instrumentation.html"><strong aria-hidden="true">8.4.</strong> 0004 Add Nixago Instrumentation</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Patterns</li><li class="chapter-item expanded "><a href="patterns/four-packaging-layers.html"><strong aria-hidden="true">9.</strong> The 4 Packaging Layers</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/cli.html"><strong aria-hidden="true">10.</strong> TUI/CLI</a></li><li class="chapter-item expanded "><a href="reference/conventions.html"><strong aria-hidden="true">11.</strong> Conventions</a></li><li class="chapter-item expanded "><a href="reference/clades.html"><strong aria-hidden="true">12.</strong> Builtin Clades</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/clades/data-clade.html"><strong aria-hidden="true">12.1.</strong> Data</a></li><li class="chapter-item expanded "><a href="reference/clades/functions-clade.html"><strong aria-hidden="true">12.2.</strong> Functions</a></li><li class="chapter-item expanded "><a href="reference/clades/runnables-clade.html"><strong aria-hidden="true">12.3.</strong> Runnables</a></li><li class="chapter-item expanded "><a href="reference/clades/installables-clade.html"><strong aria-hidden="true">12.4.</strong> Installables</a></li><li class="chapter-item expanded "><a href="reference/clades/microvms-clade.html"><strong aria-hidden="true">12.5.</strong> Microvms</a></li><li class="chapter-item expanded "><a href="reference/clades/devshells-clade.html"><strong aria-hidden="true">12.6.</strong> Devshells</a></li><li class="chapter-item expanded "><a href="reference/clades/containers-clade.html"><strong aria-hidden="true">12.7.</strong> Containers</a></li><li class="chapter-item expanded "><a href="reference/clades/nixago-clade.html"><strong aria-hidden="true">12.8.</strong> Nixago</a></li></ol></li><li class="chapter-item expanded "><a href="reference/std/index.html"><strong aria-hidden="true">13.</strong> //std</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/std/cli/index.html"><strong aria-hidden="true">13.1.</strong> /cli</a></li><li class="chapter-item expanded "><a href="reference/std/devshellProfiles/index.html"><strong aria-hidden="true">13.2.</strong> /devshellProfiles</a></li><li class="chapter-item expanded "><a href="reference/std/lib/index.html"><strong aria-hidden="true">13.3.</strong> /lib</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/std/lib/fromMakesWith.html"><strong aria-hidden="true">13.3.1.</strong> /fromMakesWith</a></li><li class="chapter-item expanded "><a href="reference/std/lib/mkShell.html"><strong aria-hidden="true">13.3.2.</strong> /mkShell</a></li><li class="chapter-item expanded "><a href="reference/std/lib/writeShellEntrypoint.html"><strong aria-hidden="true">13.3.3.</strong> /writeShellEntrypoint</a></li><li class="chapter-item expanded "><a href="reference/std/lib/mkNixago.html"><strong aria-hidden="true">13.3.4.</strong> /mkNixago</a></li></ol></li><li class="chapter-item expanded "><a href="reference/std/nixago/index.html"><strong aria-hidden="true">13.4.</strong> /nixago</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/std/nixago/adrgen.html"><strong aria-hidden="true">13.4.1.</strong> /adrgen</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/conform.html"><strong aria-hidden="true">13.4.2.</strong> /conform</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/editorconfig.html"><strong aria-hidden="true">13.4.3.</strong> /editorconfig</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/lefthook.html"><strong aria-hidden="true">13.4.4.</strong> /lefthook</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/mdbook.html"><strong aria-hidden="true">13.4.5.</strong> /mdbook</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/treefmt.html"><strong aria-hidden="true">13.4.6.</strong> /treefmt</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> //automation</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/automation/devshells/index.html"><strong aria-hidden="true">14.1.</strong> /devshells</a></li></ol></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">15.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Standard Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
SPDX-FileCopyrightText: 2022 The Standard Authors
SPDX-FileCopyrightText: 2022 Kevin Amado <kamadorueda@gmail.com>

SPDX-License-Identifier: Unlicense
-->
<div align="center">
  <img src="https://github.com/divnix/std/raw/main/artwork/logo.png" width="250" />
  <h1 id="standard"><a class="header" href="#standard">Standard</a></h1>
  <p>Ship today.</span>
</div>
<!--
_By [Kevin Amado](https://github.com/kamadorueda),
with contributions from [David Arnold](https://github.com/blaggacao),
[Timothy DeHerrera](https://github.com/nrdxp)
and many more amazing people (see end of file for a full list)._
-->
<p><a href="https://github.com/divnix/std">Standard</a> is THE opinionated, generic,
<a href="https://nixos.org/manual/nix/unstable">Nix</a> <a href="https://nixos.wiki/wiki/Flakes">Flakes</a> framework
that will allow you to grow and cultivate
Nix Cells with ease. Nix Cells are the fine
art of code organization using flakes.</p>
<p><em>Once</em> your <code>nix</code> code has evolved into a giant
ball of spaghetti and nobody else except a few
select members of your tribe can still read it
with ease; and <em>once</em> to the rest of your colleagues
it has grown into an impertinence, <em>then</em> <code>std</code>
brings the overdue order to your piece of art
through a well-defined folder structure and
disciplining generic interfaces.</p>
<p>With <code>std</code>, you’ll learn how to organize your <code>nix</code>
flake outputs (‘<strong>Targets</strong>’) into <strong>Cells</strong> and
<strong>Organelles</strong> — folded into a useful
<strong>CLI &amp; TUI</strong> to also make the lives of your
colleagues easier.</p>
<p>Through more intuition and less documentation,
your team and community will finally find a
<em>canonical</em> answer to the everlasting question:
<em>What can I <strong>do</strong> with this repository?</em></p>
<hr />
<h2 id="the-std-repository-itself"><a class="header" href="#the-std-repository-itself">The <code>std</code> repository itself</a></h2>
<p>In this repository, you’ll find, both, the <em>implementation</em> and an <em>application</em> of <a href="https://github.com/divnix/std">Standard</a>.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p><em>What is <code>std</code>? — The well-commented <code>nix</code> code → <a href="https://github.com/divnix/std/tree/main/src"><code>./src</code></a>.</em></p>
<p>That folder implements:</p>
<ul>
<li><a href="https://github.com/divnix/std/blob/main/src/grow.nix"><code>std.grow</code></a>: the “smart” importer</li>
<li><a href="https://github.com/divnix/std/blob/main/src/grow-on.nix"><code>std.growOn</code></a>: <code>std.grow</code>-variant that recursively merges all additional variadic arguments</li>
<li><a href="https://github.com/divnix/std/blob/main/src/harvest.nix"><code>std.harvest</code></a>: harvest your <strong>Targets</strong> into a different shape for compatibility</li>
<li><a href="https://github.com/divnix/std/blob/main/src/incl.nix"><code>std.incl</code></a>: a straight-forward source filter with additive semantics</li>
<li><a href="https://github.com/divnix/std/blob/main/src/de-systemize.nix"><code>std.deSystemize</code></a>: a helper to hide <code>system</code> from plain sight</li>
<li><a href="https://github.com/divnix/std/blob/main/src/clades.nix"><code>std.&lt;clade&gt;</code></a>: builtin <strong>Organelle</strong> types that implement <strong>Actions</strong></li>
</ul>
<p><em>What is this crazy verbiage? → Unambiguous identifiers on the phone.</em> ☎️</p>
<h3 id="application"><a class="header" href="#application">Application</a></h3>
<p><em>Dog-fooding? → <a href="https://github.com/divnix/std/tree/main/cells"><code>./cells</code></a>.</em></p>
<ul>
<li><strong>Cells:</strong> this is no big monorepo, so <a href="https://github.com/divnix/std/tree/main/cells"><code>./cells</code></a> only implements a single <strong>Cell</strong>: <a href="https://github.com/divnix/std/tree/main/cells/std"><code>std</code></a>.</li>
<li><strong>Organelles:</strong> <a href="https://github.com/divnix/std/tree/main/cells/std"><code>std</code></a> implements the <a href="https://github.com/divnix/std/blob/main/cells/std/cli.nix"><code>cli</code></a>,
<a href="https://github.com/divnix/std/blob/main/cells/std/devshellProfiles.nix"><code>devshellProfiles</code></a>, <a href="https://github.com/divnix/std/blob/main/cells/std/devshells.nix"><code>devshells</code></a>
&amp; <a href="https://github.com/divnix/std/blob/main/cells/std/lib/default.nix"><code>lib</code></a> <strong>Organelle</strong>.</li>
<li><strong>Targets:</strong> <a href="https://github.com/divnix/std/blob/main/cells/std/cli.nix"><code>cli</code></a>, <a href="https://github.com/divnix/std/blob/main/cells/std/devshellProfiles.nix"><code>devshellProfiles</code></a> &amp; <a href="https://github.com/divnix/std/blob/main/cells/std/devshells.nix"><code>devshells</code></a>
each only implement a <code>default</code> <strong>Target</strong>. <a href="https://github.com/divnix/std/blob/main/cells/std/lib/default.nix"><code>lib</code></a> has more.</li>
<li><strong>Actions:</strong> some <strong>Targets</strong> have <strong>Actions</strong> derived from the <strong>Organelles</strong>. See <a href="https://github.com/divnix/std/blob/main/flake.nix"><code>./flake.nix</code></a>
for the defined <strong>Organelles</strong>. Not all <strong>Clades</strong> implement <strong>Actions</strong>.</li>
</ul>
<pre><code class="language-nix">{
  growOn,
  inputs,
  clades,
  harvest,
}:
growOn {
  inherit inputs;
  cellsFrom = ./cells;
  organelles = [
    (clades.runnables &quot;cli&quot;)
    (clades.functions &quot;lib&quot;)
    (clades.functions &quot;devshellProfiles&quot;)
    (clades.devshells &quot;devshells&quot;)
    (clades.installables &quot;packages&quot;)
    (clades.nixago &quot;nixago&quot;)
    (clades.data &quot;data&quot;)
    (clades.files &quot;files&quot;)
  ];
} {
  devShells = harvest inputs.self [&quot;automation&quot; &quot;devshells&quot;];
  packages = harvest inputs.self [[&quot;std&quot; &quot;cli&quot;] [&quot;std&quot; &quot;packages&quot;]];
}
</code></pre>
<p><em>That’s it. <code>std.grow</code> is a “smart” importer of your <code>nix</code> code and is designed to keep boilerplate at bay.</em></p>
<blockquote>
<p><strong>TIP:</strong>
Now, enter the devshell (<code>direnv allow</code>) and play with the <code>std</code> CLI/TUI companion.
It answers one critical question to newcomers and veterans alike:</p>
<center><i>What can I <b>do</b> with this repository?</i></center>
&emsp;
</blockquote>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<p><em>Where can I find the documentation? → <a href="https://github.com/divnix/std/tree/main/docs"><code>./docs</code></a>.</em></p>
<p><em>No, I mean rendered? → <a href="https://divnix.github.io/std">The Standard Book</a>.</em></p>
<p>The documentation is structured around these axes:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>For Study</th><th>For Work</th></tr></thead><tbody>
<tr><td><strong>The Practice</strong></td><td>Tutorials</td><td>How-To Guides</td></tr>
<tr><td><strong>The Theory</strong></td><td>Explanation</td><td>Reference</td></tr>
</tbody></table>
</div>
<h3 id="licenses"><a class="header" href="#licenses">Licenses</a></h3>
<p><em>What licenses are used? → <a href="https://github.com/divnix/std/blob/main/.reuse/dep5"><code>./.reuse/dep5</code></a>.</em></p>
<p><em>And the usual copies? → <a href="https://github.com/divnix/std/tree/main/LICENSES"><code>./LICENSES</code></a>.</em></p>
<h2 id="releases"><a class="header" href="#releases">Releases</a></h2>
<p>You may find releases on the <a href="https://github.com/divnix/std/releases">GitHub Release Page</a> of this repository.</p>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<ul>
<li><a href="https://divnix.github.io/std/explain/why-nix.html">Why <code>nix</code>?</a></li>
<li><a href="https://divnix.github.io/std/explain/why-std.html">Why <code>std</code>?</a></li>
</ul>
<h2 id="examples-in-the-wild"><a class="header" href="#examples-in-the-wild">Examples in the Wild</a></h2>
<p>If you’d like to see some examples
of what a <a href="https://github.com/divnix/std">Standard</a> project looks like,
take a look at the following:</p>
<ul>
<li><a href="https://github.com/input-output-hk/bitte-cells"><code>input-output-hk/bitte-cells</code></a></li>
<li><a href="https://github.com/divnix/hive"><code>divnix/hive</code></a></li>
<li><a href="https://github.com/input-output-hk/tullia"><code>input-output-hk/tullia</code></a></li>
<li><a href="https://github.com/input-output-hk/mdbook-kroki-preprocessor"><code>mdbook-kroki-preprocessor</code></a></li>
<li><a href="https://github.com/hardenedlinux/HardenedNixOS-Profile"><code>HardenedNixOS-Profile</code></a></li>
<li><a href="https://github.com/JuliaCN/Julia2Nix.jl"><code>Julia2Nix.jl</code></a></li>
<li><a href="https://github.com/input-output-hk/cardano-world"><code>inputs-output-hk/cardano-world</code></a></li>
</ul>
<p>:construction: Work in progress, would like to help us extend this section?</p>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Please enter the development environment:</p>
<pre><code class="language-console">direnv allow
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p><a href="https://github.com/divnix/std">Standard</a> features a special project structure
that brings some awesome innovation
to this often overlooked (but important) part of your project.
With the default <strong>Organelles</strong>, an <code>apps.nix</code> file tells <a href="https://github.com/divnix/std">Standard</a>
that we are creating an Application.
<code>flake.nix</code> is in charge
of explicitly defining
the inputs of your project.</p>
<h4 id="flakenix"><a class="header" href="#flakenix"><code>./flake.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;
  inputs.nixpkgs.url = &quot;nixpkgs&quot;;

  outputs = {std, ...} @ inputs:
    std.grow {
      inherit inputs;
      cellsFrom = ./cells;
    };
}
</code></pre>
<h4 id="cellshelloappsnix"><a class="header" href="#cellshelloappsnix"><code>./cells/hello/apps.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: {
  default = inputs.nixpkgs.stdenv.mkDerivation rec {
    pname = &quot;hello&quot;;
    version = &quot;2.10&quot;;
    src = inputs.nixpkgs.fetchurl {
      url = &quot;mirror://gnu/hello/${pname}-${version}.tar.gz&quot;;
      sha256 = &quot;0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i&quot;;
    };
  };
}
</code></pre>
<pre><code class="language-bash">$ cd hello-world
# fetch `std`
$ nix shell github:divnix/std
$ std //hello/apps/default:run
Hello, world!
</code></pre>
<p>You see? from nothing
to running your first application
in just a few seconds ✨</p>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>This example consumes the following defaults or builtins:</p>
<h3 id="default-organelles"><a class="header" href="#default-organelles"><a href="https://github.com/divnix/std/blob/main/src/grow.nix#L63-L67">Default <code>organelles</code></a></a></h3>
<pre><code class="language-nix">    organelles ? [
      (clades.functions &quot;library&quot;)
      (clades.runnables &quot;apps&quot;)
      (clades.installables &quot;packages&quot;)
    ],
</code></pre>
<h3 id="default-systems"><a class="header" href="#default-systems"><a href="https://github.com/divnix/std/blob/main/src/grow.nix#L68-L77">Default <code>systems</code></a></a></h3>
<pre><code class="language-nix">    systems ? [
      # Tier 1
      &quot;x86_64-linux&quot;
      # Tier 2
      &quot;aarch64-linux&quot;
      &quot;x86_64-darwin&quot;
      # Other platforms with sufficient support in stdenv which is not formally
      # mandated by their platform tier.
      &quot;aarch64-darwin&quot; # a lot of apple M1 already out there
    ],
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-moon"><a class="header" href="#hello-moon">Hello Moon</a></h1>
<p><em>A slightly more complete <a href="tutorials/hello-moon/../hello-world">hello world</a> tutorial.</em></p>
<p>This tutorial implements a very typical <code>automation</code> Cell and its Organelles for a somewhat bigger project.
It also makes use of more advanced functions of <code>std</code>.
Namely:</p>
<ul>
<li><code>std.growOn</code> instead of <code>std.grow</code></li>
<li><code>std.harvest</code> to provide compatibility layers of “soil”</li>
<li>non-default Organelle definitions</li>
<li>the input debug facility</li>
</ul>
<p>The terms <em>“Clade”</em>, <em>“Cell”</em>, <em>“Organelle”</em>, <em>“Target”</em> and <em>“Action”</em> have special meaning within the context of <code>std</code>.
With these clear definitions, we navigate and communicate the code structure much more easily.
In order to familiarize yourself with them, please have a quick glance at the <a href="tutorials/hello-moon/../../glossary.html">glossary</a>.</p>
<h2 id="file-layout"><a class="header" href="#file-layout">File Layout</a></h2>
<p>Let’s start again with a flake:</p>
<h4 id="flakenix-1"><a class="header" href="#flakenix-1"><code>./flake.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;
  inputs.nixpkgs.url = &quot;nixpkgs&quot;;

  outputs = {std, ...} @ inputs:
  /*
  brings std attributes into scope
  namely used here: `growOn`, `harvest` &amp; `clades`
  */
    with std;
    /*
    grows a flake &quot;from cells&quot; on &quot;soil&quot;; see below...
    */
      growOn {
        /*
        we always inherit inputs and expose a deSystemized version
        via {inputs, cell} during import of organelles.
        */
        inherit inputs;

        /*
        from where to &quot;grow&quot; cells?
        */
        cellsFrom = ./nix;

        /*
        custom organelles (i.e. &quot;typed outputs&quot;)
        */
        organelles = [
          (clades.devshells &quot;devshells&quot;)
          (clades.nixago &quot;nixago&quot;)
        ];

        /*
        This debug facility helps you to explore what attributes are available
        for a given input untill you get more familiar with `std`.
        */
        debug = [&quot;inputs&quot; &quot;std&quot;];
      }
      /*

      Soil is an idiom to refer to compatibility layers that are recursively
      merged onto the outputs of the `std.grow` function.

      */
      # Soil ...
      # 1) layer for compat with the nix CLI
      {
        devShells = harvest inputs.self [&quot;automation&quot; &quot;devshells&quot;];
      }
      # 2) there can be various layers; `growOn` is a variadic function
      {};
}
</code></pre>
<p>This time we specified <code>cellsFrom = ./nix;</code>.
This is gentle so that our colleagues know immediately which files to either look or never look at depending on where they stand.</p>
<p>We also used <code>std.growOn</code> instead of <code>std.grow</code> so that we can add compatibility layers of “soil”.</p>
<p>Furthermore, we only defined two Organelles: <code>nixago</code> &amp; <code>devshells</code>. More on them follows…</p>
<h4 id="nixautomation"><a class="header" href="#nixautomation"><code>./nix/automation/*</code></a></h4>
<p>Next, we define a <code>automation</code> cell.
Each project will have some amount of automation.
This can be repository automation, such as code generation.
Or it can be a CI/CD specification.
In here, we wire up two tools from the Nix ecosystem: <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code></a> &amp; <a href="https://github.com/nix-community/nixago"><code>nix-community/nixago</code></a>.</p>
<blockquote>
<p><em>Please refer to these links to get yourself a quick overview before continuing this tutorial, in case you don’t know them, yet.</em></p>
<p>A <em>very</em> short refresher:</p>
<ul>
<li><strong>Nixago</strong>: Template &amp; render repository (dot-)files with nix. <a href="tutorials/hello-moon/../../explain/why-nix.html">Why nix?</a></li>
<li><strong>Devshell</strong>: Friendly &amp; reproducible development shells — the original ™.</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Some semantic background:</strong></p>
<p>Both, Nixago &amp; Devshell are <em>Component Tools</em>.</p>
<p><em>(Vertical) Component Tools</em> are distinct from <em>(Horizontal) Integration Tools</em> — such as <code>std</code> — in that they provide a specific capability in a minimal linux style: <em>“Do one thing and do it well.”</em></p>
<p>Integration Tools however combine them into a polished user story and experience.</p>
<p>The Nix ecosystem is very rich in <em>component tools</em>, however only few <em>integration tools</em> exist at the time of writing.</p>
</blockquote>
<h4 id="nixautomationdevshellsnix"><a class="header" href="#nixautomationdevshellsnix"><code>./nix/automation/devshells.nix</code></a></h4>
<p>Let’s start with the <code>cell.devshells</code> Organelle and work our way backwards to the <code>cell.nixago</code> Organelle below.</p>
<blockquote>
<p><strong>More semantic background:</strong></p>
<p>I could also reference them as <code>inputs.cells.automation.devshells</code> &amp; <code>inputs.cells.automation.nixago</code>.</p>
<p>But, because we are sticking with the local Cell context, we don’t want to confuse the future code reader.
Instead, we gently hint at the locality by just referring them via the <code>cell</code> context.</p>
</blockquote>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  /*
  I usually just find it very handy to alias all things library onto `l`...
  The distinction between `builtins` and `nixpkgs.lib` has little practical
  relevance, in most scenarios.
  */
  l = nixpkgs.lib // builtins;

  /*
  It is good practice to in-scope:
  - inputs by *name*
  - other Cells by their *Cell names*
  - the local Cell's Organelles by their *Organelle names*.

  However, for `std`, we make an exeption and in-scope, despite being an
  input, it's primary Cell with the same name.
  */
  inherit (inputs) nixpkgs;
  inherit (inputs.std) std;
  inherit (cell) nixago;
in
  # we use Standard's mkShell wrapper for its Nixago integration
  l.mapAttrs (_: std.lib.mkShell) {
    default = {...}: {
      name = &quot;My Devshell&quot;;
      # This `nixago` option is a courtesy of the `std` horizontal
      # integration between Devshell and Nixago
      nixago = [
        # off-the-shelve from `std`
        (std.nixago.conform {configData = {inherit (inputs) cells;};})
        std.nixago.lefthook
        std.nixago.adrgen
        # modified from the local Cell
        nixago.treefmt
        nixago.editorconfig
        nixago.mdbook
      ];
      # Devshell handily represents `commands` as part of
      # its Message Of The Day (MOTD) or the built-in `menu` command.
      commands = [
        {
          package = nixpkgs.reuse;
          category = &quot;legal&quot;;
          /*
          For display, reuse already has both a `pname` &amp; `meta.description`.
          Hence, we don't need to inline these - they are autodetected:

          name = &quot;reuse&quot;;
          description = &quot;Reuse is a tool to manage a project's LICENCES&quot;;
          */
        }
      ];
      # Always import the `std` default devshellProfile to also install
      # the `std` CLI/TUI into your Devshell.
      imports = [std.devshellProfiles.default];
    };
  }
</code></pre>
<p>The <code>nixago = [];</code> option in this definition is a special integration provided by the <a href="tutorials/hello-moon/../../reference/std/lib/mkShell.html">Standard’s <code>devshell</code>-wrapper (<code>std.lib.mkShell</code>)</a>.</p>
<p><em>This is how <code>std</code> delivers on its promise of being a (horizontal) integration tool that wraps (vertical) component tools into a polished user story and experience.</em></p>
<p>Because we made use of <code>std.harvest</code> in the flake, you now can actually test out the devshell via the Nix CLI compat layer by just running <code>nix develop -c &quot;$SHELL&quot;</code> in the directory of the flake.
For a more elegant method of entering a development shell read on the <a href="tutorials/hello-moon/index.html#direnv">direnv</a> section below.</p>
<h4 id="nixautomationnixagonix"><a class="header" href="#nixautomationnixagonix"><code>./nix/automation/nixago.nix</code></a></h4>
<p>As we have seen above, the <code>nixago</code> option in the <code>cell.devshells</code> Organelle references Targets from both <code>std.nixago</code> <em>and</em> <code>cell.nixago</code>.
While you can explore <code>std.nixago</code> <a href="https://github.com/divnix/std/blob/main/cells/std/nixago.nix">here</a>, let’s now have a closer look at <code>cell.nixago</code>:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  inherit (inputs.std) std;
  /*
  While these are strictly specializations of the available
  Nixago Pebbles at `std.nixago.*`, it would be entirely
  possible to define a completely new pebble inline
  */
in {
  /*
  treefmt: https://github.com/numtide/treefmt
  */
  treefmt = std.nixago.treefmt {
    # we use the configData attribute to modify the
    # target data structure via a simple data overlay
    # (`divnix/data-merge` / `std.dmerge`) mechanism.
    configData.formatter.go = {
      command = &quot;gofmt&quot;;
      options = [&quot;-w&quot;];
      includes = [&quot;*.go&quot;];
    };
    # for the `std.lib.mkShell` integration with nixago,
    # we also hint which packages should be made available
    # in the environment for this &quot;Nixago Pebble&quot;
    packages = [nixpkgs.go];
  };

  /*
  editorconfig: https://editorconfig.org/
  */
  editorconfig = std.nixago.editorconfig {
    configData = {
      # the actual target data structure depends on the
      # Nixago Pepple, and ultimately, on the tool to configure
      &quot;*.xcf&quot; = {
        charset = &quot;unset&quot;;
        end_of_line = &quot;unset&quot;;
        insert_final_newline = &quot;unset&quot;;
        trim_trailing_whitespace = &quot;unset&quot;;
        indent_style = &quot;unset&quot;;
        indent_size = &quot;unset&quot;;
      };
      &quot;{*.go,go.mod}&quot; = {
        indent_style = &quot;tab&quot;;
        indent_size = 4;
      };
    };
  };

  /*
  mdbook: https://rust-lang.github.io/mdBook
  */
  mdbook = std.nixago.mdbook {
    configData = {
      book.title = &quot;The Standard Book&quot;;
    };
  };
}
</code></pre>
<p>In this Organelle, we have been modifying some built-in convenience <code>std.nixago.*</code> pebbles.
The way <code>configData</code> is merged upon the existing pebble is via a simple left-hand-side/right-hand-site <code>data-merge</code> (<code>std.dmerge</code>).</p>
<blockquote>
<p><strong>Background on array merge strategies:</strong></p>
<p>If you know how a plain data-merge (does not magically) deal with array merge semantics, you noticed:
We didn’t have to annotate our right-hand-side arrays in this example because we where not actually amending or modifying any left-hand-site array type data structure.</p>
<p>Would we have done so, we would have had to annotate:</p>
<ul>
<li>either with <code>std.dmerge.append [/* ... */]</code>;</li>
<li>or with <code>std.dmerge.update [ idx ] [/* ... */]</code>.</li>
</ul>
<p>But lucky us (this time)!</p>
</blockquote>
<h2 id="command-line-synthesis"><a class="header" href="#command-line-synthesis">Command Line Synthesis</a></h2>
<p>With this configuration in place, you have a couple of options on the command line.
Note, that you can accessor any <code>std</code> cli invocation also via the <code>std</code> TUI by just typing <code>std</code>.
Just in case you forgot exactly how to accessor one of these repository capabilities.</p>
<blockquote>
<p><strong>Debug Facility:</strong></p>
<p>Since the debug facility is enabled, you will see some trace output while running these commands.
To switch this off, just comment the <code>debug = [ /* ... */ ];</code> attribute in the flake.</p>
<p>It looks something like this:</p>
<pre><code class="language-nix">trace: inputs on x86_64-linux
trace: {
  cells = {…};
  nixpkgs = {…};
  self = {…};
  std = {…};
}
</code></pre>
</blockquote>
<p><strong>Invoke devshell via <code>nix</code></strong></p>
<pre><code class="language-bash">nix develop -c &quot;$SHELL&quot;
</code></pre>
<p>By quirks of the Nix CLI, if you don’t specify <code>-c &quot;$SHELL&quot;</code>, you’ll be thrown into an unfamiliar bare <code>bash</code> interactive shell.
That’s not what you want.</p>
<p><strong>Invoke the devshell via <code>std</code></strong></p>
<p>In this case, invoking <code>$SHELL</code> correctly is taken care for you by the Clade’s <code>enter</code> Action.</p>
<pre><code class="language-bash"># fetch `std`
$ nix shell github:divnix/std
$ std //automation/devshells/default:enter
</code></pre>
<p>Since we have declared the devshell Organelle as a <code>clades.devshells</code>, <code>std</code> auments it’s Targets with the Clade Actions.</p>
<p>See <a href="tutorials/hello-moon/../../reference/clades/devshells-clade.html"><code>clades.devshells</code></a> for more details on the available Actions and their implementation.</p>
<p>Thanks to the <code>cell.devshells</code>’ <code>nixago</code> option, entering the devshell will also automatically reconcile the repository files under Nixago’s management.</p>
<p><strong>Explore a Nixago Pebble via <code>std</code></strong></p>
<p>You can also explore the nixago configuration via the Nixago Clade’s <code>explore</code>-Action.</p>
<pre><code class="language-bash"># fetch `std`
$ nix shell github:divnix/std
$ std //automation/nixago/treefmt:explore
</code></pre>
<p>See <a href="tutorials/hello-moon/../../reference/clades/nixago-clade.html"><code>clades.nixago</code></a> for more details on the available Actions and their implementation.</p>
<h2 id="direnv"><a class="header" href="#direnv">direnv</a></h2>
<p>Manually entering the devshell is boring.
How about a daemon always does that automatically &amp; efficiently when you <code>cd</code> into a project directory?
Enter <a href="https://direnv.net"><code>direnv</code></a> — the original (again; and even from the same author) 😊.</p>
<p>Before you continue, first install direnv according to it’s <a href="https://direnv.net/docs/installation.html">install instructions</a>.
It’s super simple &amp; super useful ™ and you should do it <em>right now</em> if you haven’t yet.</p>
<p>Please learn how to enable <code>direnv</code> in this project by following the <a href="tutorials/hello-moon/../../guides/envrc.html">direnv how-to</a>.</p>
<p>In this case, you would adapt the relevant line to: <strong><code>use std nix //automation/devshells:default</code></strong>.</p>
<p>Now, you can simply <code>cd</code> into that directory, and the devshells is being loaded.
The MOTD will be shown, too.</p>
<p>The first time, you need to teach the <code>direnv</code> daemon to trust the <code>.envrc</code> file via <code>direnv allow</code>.
If you want to reload the devshell (e.g. to reconcile Nixago Pepples), you can just run <code>direnv reload</code>.</p>
<p>Because I use these commands so often, I’ve set: <code>alias d=&quot;direnv&quot;</code> in my shell’s RC file.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="growing-cells"><a class="header" href="#growing-cells">Growing Cells</a></h1>
<p>Growing cells can be done via two variants:</p>
<ul>
<li><code>std.grow { cellsFrom = &quot;...&quot;; /* ... */ }</code></li>
<li><code>std.growOn { cellsFrom = &quot;...&quot;; /* ... */ } # soil</code></li>
</ul>
<h2 id="stdgrowon---soil"><a class="header" href="#stdgrowon---soil"><code>std.growOn {} # soil</code></a></h2>
<p>This eases talking and reasoning about a <code>std</code>ized repository, that also needs
some sort of adapters to work together better with external frameworks.</p>
<p>Typically, you’d arrange those adapters in numbered layers of soil, just
so that it’s easier to conceptually reference them when talking / chatting.</p>
<p>It’s a variadic function and takes an unlimited number of “soil layers”.</p>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;

  outputs = {std, ...} @ inputs:
    std.growOn {
      inherit inputs;
      cellsFrom = ./cells;
    }
    # soil
    () # first layer
    () # second layer
    () # ... nth layer
    ;
}
</code></pre>
<p>These layers get recursively merged onto the output of <code>std.grow</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="include-filter"><a class="header" href="#include-filter">Include Filter</a></h1>
<p>It is very common that you want to filter your source code in order
to avoid unnecessary rebuilds and increase your cache hits.</p>
<p>This is so common that <code>std</code> includes a tool for this:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  inherit (inputs) std;
in {
  backend = nixpkgs.mkYarnPackage {
    name = &quot;backend&quot;;
    src = std.incl (inputs.self + /src/backend) [
      (inputs.self + /src/backend/app.js)
      (inputs.self + /src/backend/config/config.js)
      /* ... */
    ];
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-envrc"><a class="header" href="#setup-envrc">Setup <code>.envrc</code></a></h1>
<p>Standard provides an extension to the <code>stdlib</code> via <code>direnv_lib.sh</code>.</p>
<p>The integrity hash below ensures it is downloaded only once and cached
from there on.</p>
<pre><code class="language-bash">#! /bin/sh

# SPDX-FileCopyrightText: 2022 David Arnold &lt;dgx.arnold@gmail.com&gt;
# SPDX-FileCopyrightText: 2022 Kevin Amado &lt;kamadorueda@gmail.com&gt;
#
# SPDX-License-Identifier: Unlicense

source &quot;$(
  nix eval \
  --no-update-lock-file \
  --no-write-lock-file \
  --no-warn-dirty \
  --accept-flake-config \
  .#__std.direnv_lib 2&gt;/dev/null
)&quot;
use std cells //automation/devshells:default
</code></pre>
<blockquote>
<p><strong>NOTE:</strong>
In the above code <code>use std</code> <strong><code>cells</code></strong> <code>//std/...</code> refers to the
folder where <strong>Cells</strong> are grown from. If your folder is e.g. <code>nix</code>, adapt
to <code>use std</code> <strong><code>nix</code></strong> <code>//...</code> and so forth.</p>
</blockquote>
<p>It is used to automatically set up file watches on files that could modify the
current devshell, discoverable through these or similar logs during loading:</p>
<pre><code class="language-console">direnv: loading https://raw.githubusercontent.com/divnix/std/...
direnv: using std cells //automation/devshells:default
direnv: Watching: cells/automation/devshells.nix
direnv: Watching: cells/automation/devshells (recursively)
</code></pre>
<p>For reference, the above example loads the <code>default</code> devshell from:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
  inherit (inputs.cells) std;
in
  l.mapAttrs (_: std.lib.mkShell) {
    default = {
      extraModulesPath,
      pkgs,
      ...
    }: {
      name = &quot;Standard&quot;;
      nixago = [
        (std.nixago.conform {configData = {inherit (inputs) cells;};})
        cell.nixago.treefmt
        cell.nixago.editorconfig
        cell.nixago.mdbook
        std.nixago.lefthook
        std.nixago.adrgen
      ];
      commands =
        [
          {
            package = nixpkgs.reuse;
            category = &quot;legal&quot;;
          }
          {
            package = nixpkgs.delve;
            category = &quot;cli-dev&quot;;
            name = &quot;dlv&quot;;
          }
          {
            package = nixpkgs.go;
            category = &quot;cli-dev&quot;;
          }
          {
            package = nixpkgs.gotools;
            category = &quot;cli-dev&quot;;
          }
          {
            package = nixpkgs.gopls;
            category = &quot;cli-dev&quot;;
          }
        ]
        ++ l.optionals nixpkgs.stdenv.isLinux [
          {
            package = nixpkgs.golangci-lint;
            category = &quot;cli-dev&quot;;
          }
        ];
      imports = [
        std.devshellProfiles.default
      ];
    };
    checks = {
      pkgs,
      config,
      ...
    }: {
      name = &quot;checks&quot;;
      imports = [
        std.devshellProfiles.default
      ];
      commands = [
        {
          name = &quot;clade-data&quot;;
          command = &quot;cat $(std //tests/data/example:write)&quot;;
        }
        {
          name = &quot;clade-devshells&quot;;
          command = &quot;std //std/devshell/default:enter -- echo OK&quot;;
        }
        {
          name = &quot;clade-runnables&quot;;
          command = &quot;std //std/cli/default:run -- std OK&quot;;
        }
      ];
    };
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-nix"><a class="header" href="#why-nix">Why <code>nix</code>?</a></h1>
<p>A lot of people write a lot of confusing stuff about nix.</p>
<p>So here, we’ll try to break it down, instead.</p>
<h2 id="nix-is-json-on-steroids"><a class="header" href="#nix-is-json-on-steroids"><code>nix</code> is “<code>json</code> on steroids”</a></h2>
<p>In configuration management, you have a choice: data vs. language.</p>
<p>On stackoverflow, you’ll be taught the “data” stance, because it’s simple.</p>
<p>And all of a sudden you hit reality. Outside of a “lab” environment, you suddenly
need to manage a varying degree of complexity.</p>
<p>So you need configuration combinators, or in other words a full blown language
to efficiently render your configurations.</p>
<p>There are a couple of options, that you’ll recognize if you’ve gotten serious about
the configuration challenge, like:</p>
<ul>
<li><a href="https://dhall-lang.org/"><code>dhall</code></a></li>
<li><a href="https://cuelang.org/"><code>cue</code></a></li>
<li><a href="https://jsonnet.org/"><code>jsonnet</code></a></li>
<li><a href="https://nickel-lang.org/"><code>nickel</code></a></li>
</ul>
<p>And there is <a href="https://nixos.org/"><code>nix</code></a>, the language. In most aspects, it isn’t hugely distinct from the others,
but it has superpowers. Read on!</p>
<h2 id="nix-superpowers"><a class="header" href="#nix-superpowers"><code>nix</code>’ superpowers</a></h2>
<p>You know the concept of string interpolation.</p>
<p>Every time <code>nix</code> interpolates an identifier, there is something that
you don’t immediately see: it keeps a so called “string context” right
at the site of interpolation. That string context holds a directed acyclic
graph of all the dependencies that are required to make that string.</p>
<p>“Well, it’s just a string; what on earth should I need to make a string?”, you may say.</p>
<p>There is a special category of strings, so called “Nix store paths”
(strings that start with <code>/nix/store/...</code>). These store paths represent
build artifacts that are content addressed ahead-of-time through
the inputs of an otherwise pure build function, called <a href="https://nixos.org/manual/nix/stable/expressions/derivations.html"><code>derivation</code></a>.</p>
<p>When you finally reify (i.e. “build”) your string interpolation, then all these Nix store
paths get build as well.</p>
<p>This might be a bit of a mind-boggling angle, but after a while, you may realize:</p>
<ul>
<li>Nix is a massive build pipeline that tracks all things to their source.</li>
<li>In their capacity as <em>pure</em> build functions, <a href="https://nixos.org/manual/nix/stable/expressions/derivations.html"><code>derviation</code>s</a> build <em>reproducibly</em>.</li>
<li>Reproducible builds are the future of software supply chain security, among other things.</li>
<li>You’ll start asking: “who the heck invented all that insecure nonsense of opaque binary registries?
Shouldn’t have those smart people have known better?”</li>
<li>And from this realization, there’s no coming back.</li>
<li>And you’ll have joined the <a href="https://discourse.nixos.org/t/nixos-foundation-participating-in-eus-next-generation-internet-initiative/2011">European Union</a>, <a href="https://discourse.nixos.org/t/mercury-bank-nix-engineers/13784">banks</a> and <a href="https://github.com/input-output-hk/cardano-world">blockchain companies</a> who also realized:
we need to fix our utterly broken and insecure build systems!</li>
<li>By that time, you’ll have already assimilated the legendary <a href="http://users.ece.cmu.edu/%7Eganger/712.fall02/papers/p761-thompson.pdf">Ken Thompson’s “Reflections on Trusting Trust”</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-std"><a class="header" href="#why-std">Why std?</a></h1>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>Nix is marvel to ones and cruelty to others.</p>
<p>Much of this professional schism is due to two fundamental issues:</p>
<ul>
<li>Nix is a functional language without typing</li>
<li>Therefore, Nix-enthusiast seem to freaking love writing the most elegant and novel boilerplate all over again the next day.</li>
</ul>
<p>The amount of domain specific knowledge required to untangle those most elegant and novel boilerplate patterns prevent
the other side of the schism, very understandably, to see through the smoke the true beauty and benefits of <code>nix</code> as a
build and configuration language.</p>
<p>Lack of typing adds to the problem by forcing <code>nix</code>-practitioners to go out of their way (e.g. via <a href="https://github.com/divnix/yants"><code>divnix/yants</code></a>) to
add some internal boundaries and contracts to an ever morphing global context.</p>
<p>As a consequence, few actually <em>do</em> that. And contracts across internal code boundaries are either absent or rudimentary or — yet again —
“elegant and novel”. Neither of which satisfactorily settles the issue.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p><code>std</code> doesn’t add language-level typing. But a well-balanced folder layout cut at 3 layers of conceptual
nesting provides the fundamentals for establishing internal boundaries.</p>
<blockquote>
<p><strong>Cell → Organelle → Target → [Action]</strong></p>
<p>Where …</p>
<ul>
<li><strong>Cells</strong> group functionality.</li>
<li><strong>Organelles</strong> type outputs and implement <strong>Actions</strong>.</li>
<li><strong>Targets</strong> name outputs.</li>
</ul>
</blockquote>
<p>Programmers are really good at pattern-abstraction when looking at two similar but slightly
different things: <em><strong>Cells</strong> and <strong>Organelles</strong> set the stage for code readability.</em></p>
<p><strong>Organelles</strong> only allow one possible interface: <code>{inputs, cell}</code>:</p>
<ul>
<li><code>cell</code> the local <strong>Cell</strong>, promoting separation of concern</li>
<li><code>inputs</code> the <code>deSystemize</code>ed flake inputs — plus:
<ul>
<li><code>inputs.self = self.sourceInfo;</code> reference source code in <code>nix</code>; filter with <code>std.incl</code>; don’t misuse the global <code>self</code>.</li>
<li><code>inputs.cells</code>: the other cells by name; code that documents its boundaries.</li>
<li><code>inputs.nixpkgs</code>: an <em>instantiated</em> <code>nixpkgs</code> for the current system;</li>
</ul>
</li>
</ul>
<p>Now, we have <em>organized</em> <code>nix</code> code. Still, <code>nix</code> is not for everybody.
And for everybody else the <code>std</code> TUI/CLI companion answers a single question to perfection:</p>
<blockquote>
<p><strong>The GitOps Question:</strong></p>
<center><i>What can I actually <b>do</b> with this <code>std</code>-ized repository?</i></center>
&emsp;
</blockquote>
<blockquote>
<p><strong>The Standard Answer:</strong></p>
<center><i><code>std</code> breaks down GitOps into a single UX-optimized TUI/CLI entrypoint.</i></center>
&emsp;
</blockquote>
<h2 id="benefit"><a class="header" href="#benefit">Benefit</a></h2>
<p>Not everybody is going to love <code>nix</code> now.</p>
<p>But the ones, who know its secrets, now have an effective tool
to more empathically spark the joy.</p>
<p>Or simply: 💔 → 🧙 → 🔧 → ✨→ 🏖️</p>
<p>The smallest common denominator, in any case:</p>
<blockquote>
<p>Only ever install a single dependency (<code>nix</code>) and reach <em>any</em> repository target. Reproducibly.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-decision-record"><a class="header" href="#architecture-decision-record">Architecture Decision Record</a></h1>
<p>An architecture decision record (ADR) is a document that captures an
important architectural decision made along with its context and consequences.</p>
<p>The template in this folder has all the info.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To interact with this ADR, enter the devshell and interact though the <code>adrgen</code> tool.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-drop-as-nix-cli-epiphyte-flag"><a class="header" href="#3-drop-as-nix-cli-epiphyte-flag">3. Drop <code>as-nix-cli-epiphyte</code> flag</a></h1>
<p>Date: 2022-04-28</p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>accepted</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>Currently, <code>std.grow</code> has a <code>as-nix-cli-epiphyte</code> flag to make the output scheme
compatible with the <code>nix</code> CLI output scheme.</p>
<p>However, part of the raison-d’etre of <code>std</code> are the deficiencies of the <code>nix</code> CLI
output scheme.</p>
<p>With the introduction of a TUI and soon a CLI equivalence, the need for matching
the <code>nix</code> CLI interface is diminishing.</p>
<p>For part of the target audience of <code>std</code>, however, the <code>nix</code> CLI interface is a
productivity sink and not really a good day to day companion.</p>
<p>Especially at the intersection of <code>nix</code> experts and non-nix experts, that particular
aspect might be neglected by experienced <code>nix</code> experts that come with different
priorities, habits and workflows.</p>
<h2 id="decision"><a class="header" href="#decision">Decision</a></h2>
<p>To cater the purpose of <code>std</code> to make this a productive Nix-related framework for
teams, we remove the <code>as-nix-cli-epiphyte</code> flag and thereby discourage the wide-spread
and general purpose use of the <code>nix</code> CLI.</p>
<p>If such interoperability is still needed, a layer of soil can bring back the necessary
adapter.</p>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<p>Nix experts that are making use of <code>std</code> outside of the above described context might
prefer to add back a nix cli adapter as a layer of soil. However, being experts and
knowing their needs, this is probably not a huge show stopper.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-wire-up-documentation-instrumentation"><a class="header" href="#2-wire-up-documentation-instrumentation">2. Wire up documentation instrumentation</a></h1>
<p>Date: 2022-04-20</p>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<p>superseded</p>
<p>Superseded by <a href="explain/architecture-decision-records/0004-add-nixago-instrumentation.html">4. Add Nixago Instrumentation</a></p>
<h2 id="context-1"><a class="header" href="#context-1">Context</a></h2>
<p>Documentation instrumentation is always necessary. But because there are so many options,
oftentimes it’s not the first thing to do when kick-starting a project.</p>
<p>Either because fingers are eager to hack or because the myriad of options stalls efficient
decision making.</p>
<h2 id="decision-1"><a class="header" href="#decision-1">Decision</a></h2>
<p>In this context, we want to provide a default doc instrumentation setup, that, at the very
minimum is capable of rendering and hosting the ADRs.</p>
<p>Batteries included &amp; (this time) not removable.</p>
<p><em>You can have any color you like as long as it’s black.</em></p>
<h2 id="consequences-1"><a class="header" href="#consequences-1">Consequences</a></h2>
<p>As a consequence, entering a devshell, and if no <code>book.toml</code> exists, a minimal layout will be
created.</p>
<p>The user is then expected to fill it with life according to the <code>mdbook</code> docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-increase-repo-discoverability-with-a-tui"><a class="header" href="#1-increase-repo-discoverability-with-a-tui">1. Increase repo discoverability with a TUI</a></h1>
<p>Date: 2022-04-20</p>
<h2 id="status-2"><a class="header" href="#status-2">Status</a></h2>
<p>accepted</p>
<h2 id="context-2"><a class="header" href="#context-2">Context</a></h2>
<p>In general, the more a polyglot repository grows, the more folks need very contextual knowledge to
assess the old and still same question: “What’s in it for me?” / WIIFM.</p>
<p>And once they find an answer to that question, already ensues the next: “And how do I make use of it?”.</p>
<p>Finding an answer to these questions is regularly not trivial and hugely language specific.</p>
<p>The classic solution always has been: “Write a (boilerplate) readme.”.</p>
<h2 id="decision-2"><a class="header" href="#decision-2">Decision</a></h2>
<p>Thanks to <code>nix</code>, we can largely outperform that classic solution.</p>
<p>So, we implement a TUI that is duly wired with the repository it represents.</p>
<p>It queries the <code>nix</code> for the necessary metadata including targets and
the target’s actions.</p>
<p>It also detects well-placed readme files and presents them contextually on the CLI
to the user.</p>
<p>The user can then fuzzy search any desired target, query its contextual help or choose
one of the actions for execution.</p>
<h2 id="consequences-2"><a class="header" href="#consequences-2">Consequences</a></h2>
<p>Not only in a polyglot repository, the different stakeholders can now easily and naturally
interact (“speak”) with the repository.</p>
<p>This has the potential of optimizing away a lot of very engrained media-breaks that today sometimes
render massive collaboration across a broad team increasingly friction-laden.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-add-nixago-instrumentation"><a class="header" href="#4-add-nixago-instrumentation">4. Add Nixago Instrumentation</a></h1>
<p>Date: 2022-07-29</p>
<h2 id="status-3"><a class="header" href="#status-3">Status</a></h2>
<p>accepted</p>
<p>Supersedes <a href="explain/architecture-decision-records/0002-wire-up-documentation-instrumentation.html">2. Wire up documentation instrumentation</a></p>
<h2 id="context-3"><a class="header" href="#context-3">Context</a></h2>
<p>The current implementation of mdbook instrumentation and adrgen instrumentation is brittle and ad-hoc.
Furthermore, the making these two “special” is a contentious decision.</p>
<p>Adjacently, oftentimes, there are other “repo dotfiles” that we want to somehow centrally manage (and
auto-update), instead of copy pasting them for the n-th time.</p>
<p>Recently, the Nixago project has seen the face of the earth which deals precisely with repo dotfile
templating and linking/copying.</p>
<h2 id="decision-3"><a class="header" href="#decision-3">Decision</a></h2>
<p>Implement a first class integreation with Nixago and add the appropriate glue-code to work seamlessly
together with Devshells.</p>
<p>Ship some generic Nixago Pebbles as part of the <code>std</code> Celle.</p>
<h2 id="consequences-3"><a class="header" href="#consequences-3">Consequences</a></h2>
<ul>
<li>mdbook / adgen dotfile templating is no more “special”</li>
<li>user can make use of this instrumentation to template <em>any</em> repo dotfile</li>
<li>user can reuse the shipped Nixago Pebbles and take inspiration from our dogfooding</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><em>This is an opinionated pattern.</em></p>
<p><em>It helps structure working together on microservices with <code>std</code>.</em></p>
</blockquote>
<h1 id="the-4-layers-of-packaging"><a class="header" href="#the-4-layers-of-packaging">The 4 Layers of Packaging</a></h1>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>We have written an application and now we want to package and run it.
For its supply chain security benefits, we have been advised to employ reproducible and source-based distribution mechanisms.
We furthermore need an interoperability platform that is generic and versatile: a <em>configuration “lingua franca”</em>.
Our peers who write another application in another language should share that same approach.
Thereby, we avoid the negative external effects of DevOps silos on integrators and operators, alike.
Short: we make adoption of our application as easy as possible for our consumers.</p>
<h2 id="the-actors"><a class="header" href="#the-actors">The Actors</a></h2>
<p><em>Note, that each actor persona can be exercised by one and the same person or a group of persons.
Although possible, and even frequently so, it doesn’t imply that these roles are necessarily taken by distinct individuals.</em></p>
<h3 id="developer"><a class="header" href="#developer">Developer</a></h3>
<p>The Developer persona incrementally modifies the source code.
At times, such modification are relevant at the interface to the Operator persona.
One such example is when the app configuration is modified.
Another one, when important runtime characteristics are amended.</p>
<h3 id="operator"><a class="header" href="#operator">Operator</a></h3>
<p>The Operator persona brings the application to production.
She typically engages in further wrapping code or other artifact creation.
She also supervises and observes the running application across different environments.</p>
<h3 id="release-manager"><a class="header" href="#release-manager">Release Manager</a></h3>
<p>The Release Manager persona cuts releases at discrete points in time.
In doing so, she procures their artifacts for general (public) consumtion.
Any release is tied to a sufficiently high level of assurance of an artifact’s desired properties.
For that purpose, she works with the Developer, Operator &amp; QA personas along these 4 layers of packaging.</p>
<h3 id="qa"><a class="header" href="#qa">QA</a></h3>
<p>The QA persona establishes various levels of assurance of an artifact’s desired properties.
Thereby, the observable artifacts can emanate from any layer of these 4 layers of packaging.
She informs the Developer, Operator and Release Manager personas about any found assurance levels.
She can do so through manual or automatic (CI) means.</p>
<h2 id="the-layers"><a class="header" href="#the-layers">The Layers</a></h2>
<pre class="mermaid">
flowchart TD
    packaging([Packaging])
    entrypoint([Entrypoint])
    image([OCI-Image])
    scheduler([Scheduler Chart])
    packaging --&gt; entrypoint
    entrypoint --&gt; image
    image --&gt; scheduler

    click packaging href &quot;#packaging-layer&quot; &quot;Jump to the packaging layer section&quot;
    click entrypoint href &quot;#entrypoint-layer&quot; &quot;Jump to the entrypoint layer section&quot;
    click image href &quot;#oci-image-layer&quot; &quot;Jump to the OCI image layer section&quot;
    click scheduler href &quot;#scheduler-chart-layer&quot; &quot;Jump to the scheduler chart layer section&quot;
`</pre>
<hr />
<p>There is one very important factoring &amp; interoperability rule about these layers:</p>
<p><em>A domain concern of a higher layer <strong>must not</strong> bleed into previous layers.</em></p>
<p>Observing this very simple rule ensures long term interoperability and maintainability of the stack.
For example, not presuming a particular scheduler in the entrypoint gives contributors a chance to easily add another scheduler target without painful refactoring.</p>
<blockquote>
<p><em><strong>Future Work:</strong> depending on how you count, there may be actually a 5th layer: the <strong>operator</strong> layer. But we may cover this in a future version of this article in further detail. If you don’t want to wait, you may have a conceptual look at the <a href="https://juju.is/docs/olm">Charmed Operator Framework</a> and <a href="https://charmhub.io/">Charmehub</a>.</em></p>
</blockquote>
<p><em>Note, that it would be possible to further fold these interfaces and a Nix veteran might be inclined to do so.
But doing so would defeat the purpose of exposing well defined layered interfaces alongside role-boundaries, subject matter concepts for ease of communication and collaboration; as well as external artifact consumers.</em></p>
<h3 id="packaging-layer"><a class="header" href="#packaging-layer">Packaging Layer</a></h3>
<pre><code class="language-yaml">Organelle: (clades.installables &quot;packages&quot;)
Location:  **/packages.nix          # or **/packages/
Actors:
 - Build Expert Panel, Nix- &amp; language-specific
 - Release Manager
</code></pre>
<p>This Organelle builds, unit-tests &amp; packages the application via the appropriate <a href="patterns/../explain/why-nix.html#nix-superpowers">Nix primitives</a>.
Each programming language has a different best practice approach to packaging.
Therfore, a fair ammount of domain knowledge between Nix and the language’s build system is required.</p>
<p>The location of the actual build instructions are secondary.
At minimum, though, for transparency’s and uniformity’s sake, they are still proxied via this Organelle.
So in the case that upstream already contains appropriate build instructions, the following indirection is perfectly valid (and necessary):</p>
<pre><code class="language-nix">{ inputs, cell }: {
  app = inputs.upstream.packages.some-app;
}
</code></pre>
<p>Build instructions themselves should encompass executing unit tests.
Builds that fail unit tests should already be filtered out at this layer (i.e. “a build that fails unit tests is no build, at all”).</p>
<p>A Release Manager may decide to provide these artifacts to the general public on tagged releases.</p>
<blockquote>
<p><strong>In a hurry?</strong></p>
<p>Fetching binary artifacts and incorporating them at this layer as a temporary work-around for non-production enviornments is acceptable.</p>
</blockquote>
<h3 id="entrypoint-layer"><a class="header" href="#entrypoint-layer">Entrypoint Layer</a></h3>
<pre><code class="language-yaml">Organelle: (clades.runnables &quot;entrypoints&quot;)
Location:  **/entrypoints.nix       # or **/entrypoints/
Actors:
 - Developer
 - Operator
</code></pre>
<p>This Organelle exclusively defines the runtime environment of the application via the entrypoint script.
The role of this script — customarily written in <code>bash</code> — serves as a concise and reified communication channel between Developers and Operators.
As such, Operators will find all the primariy configuration options re-encoded at a glance and in a well-known location.
In the other direction, Developers will find all the magic ad-hoc warpping that Operators had to engage in, in order to run the application on the target scheduler.</p>
<p>Through this communication channel, operators take reliably note of configuration drift, while Developers gain a valuable source of backlog to increase the operational robustness of the application.</p>
<p>Standard includes a <a href="patterns//reference/std/lib/writeShellEntrypoint.html">specific library function</a> that establishes an implementation-site interface for entrypoints and their collaterals which significantly eases working on the following layers.</p>
<h3 id="oci-image-layer"><a class="header" href="#oci-image-layer">OCI-Image Layer</a></h3>
<pre><code class="language-yaml">Organelle: (clades.containers &quot;oci-images&quot;)
Location:  **/oci-images.nix        # or **/oci-images/
Actors:
 - Operator
 - Release Manager
</code></pre>
<p>This layered packaging pattern promotes source-based distribution in principle.
Despite, in common operating scenarios, we require a security stop-gap separation.
This ensures very fundamentally that nothing is accidentially <em>built</em> on the target (production) worker node, where it would cannibalize critical resources.</p>
<p>We chose OCI-Images as the binary distribution format.
It not only fits that purpose through the <a href="https://github.com/opencontainers/distribution-spec">OCI Distribution Specification</a>, but also collaterally procures interoperability for 3rd parties:
OCI images are the de-facto industry standard for deployment artifacts.</p>
<p>If the entrypoints have been created via the above mentioned <a href="patterns//reference/std/lib/writeShellEntrypoint.html">library function</a>, the creation of OCI images trivially reduces to:</p>
<pre><code class="language-nix">{ inputs, cell }: {
  image-hard = cell.entrypoints.app.mkOCI &quot;docker.io/my-image-hardened&quot;;
  image = cell.entrypoints.app.mkDebugOCI &quot;docker.io/my-image&quot;;
}
</code></pre>
<p>Alternatively, any of the avaible Nix-based OCI generation mini-frameworks can be used;
<a href="https://github.com/nlewo/nix2container"><code>nlewo/nix2container</code></a> being the recommended one.
Hence, this mini-framework is internally used by the entrypoints library function.</p>
<p>A Release Manager may decide to provide these artifacts to the general public on tagged releases.</p>
<blockquote>
<p><strong>In a hurry?</strong></p>
<p>Fetching published images and incorporating them at this layer as a temporary work-around for non-production enviornments is acceptable.</p>
</blockquote>
<h3 id="scheduler-chart-layer"><a class="header" href="#scheduler-chart-layer">Scheduler Chart Layer</a></h3>
<pre><code class="language-yaml">Organelle: (clades.functions &quot;&lt;sched&gt;Charts&quot;)
Location:  **/&lt;sched&gt;Charts.nix     # or **/&lt;sched&gt;Charts/
Actors:
 - Operator
 - Release Manager
</code></pre>
<p>The scheduler chart is not <em>yet</em> mainfest data.
Rather, it is a function interface that commonly renders to such json-serializable manifest data.
These mainfests are then ingested and interpreted by the scheduler.</p>
<p>A fair amount of scheduler domain knowledge and familiarity with its scheduling options is required, especially
during creation.</p>
<p>These charts can then be processed further downstream (e.g. in Nix code) to specialize out the final manifests and environments.</p>
<p>Since these charts are the basis of various environments for development, staging and production, it is <em>highly</em> recommended to keep their function interface extremely mininmal <strong>and</strong> stable.
This avoids the risk of inadvertely modifying production manifests (e.g. via a human error in the base charts) based on a development or staging requirement.
In these cases, it is <em>highly</em> recommended to resort to data-oriented overlay mechanisms for ad-hoc modification.
A purpose-built tool to do so (called <a href="https://github.com/divnix/data-merge"><code>data-merge</code></a>) is already re-exported under <code>std.dmerge</code> for convenience.
Those modifications should only propagate into a chart interface after <em>stabilizing</em> and after having successfully percolated through all existing environments first.</p>
<p>A Release Manager may decide to provide these artifacts to the general public on tagged releases.
For example: in the transpiled form of a widely used scheduler-specific config sharing format, such as <a href="https://helm.sh/docs/topics/charts/">helm-charts</a>.</p>
<blockquote>
<p><em><strong>Future Work:</strong> it might be a feasible task to extract a common base interface among different schedulers
and thereby implement a base chart that we could simply specialize for each target schedulers (including <code>systemd</code>).
But this may be subject of future research.
Potentially, the above mentioned <a href="https://juju.is/docs/olm">Charmed Operator Framework</a> even obsoletes that need a priori and in practical terms.</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuicli"><a class="header" href="#tuicli">TUI/CLI</a></h1>
<h4 id="tuicli-1"><a class="header" href="#tuicli-1">TUI/CLI:</a></h4>
<pre><code class="language-console"># TUI
std

# CLI
std //&lt;TAB&gt;

# Version
std -v
</code></pre>
<h4 id="help"><a class="header" href="#help">Help:</a></h4>
<pre><code class="language-console">❯ std -h
std is the CLI / TUI companion for Standard.

- Invoke without any arguments to start the TUI.
- Invoke with a target spec and action to run a known target's action directly.

Usage:
std //cell/organelle/target:action [flags]

Flags:
-h, --help      help for std
-v, --version   version for std
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conventions-in-std"><a class="header" href="#conventions-in-std">Conventions in <code>std</code></a></h1>
<p>In principle, we all want to be able to read code with local reasoning.</p>
<p>However, these few conventions are pure quality of life and
help us to keep our nix code organized.</p>
<h2 id="nix-file-locations"><a class="header" href="#nix-file-locations">Nix File Locations</a></h2>
<p>Nix files are imported from either of these two locations, if present, in this order of precedence:</p>
<pre><code>${cellsFrom}/${cell}/${organelle}.nix
${cellsFrom}/${cell}/${organelle}/default.nix
</code></pre>
<h2 id="readme-file-locations"><a class="header" href="#readme-file-locations">Readme File Locations</a></h2>
<p>Readme files are picked up by the TUI in the following places:</p>
<pre><code>${cellsFrom}/${cell}/Readme.md
${cellsFrom}/${cell}/${organelle}/Readme.md
${cellsFrom}/${cell}/${organelle}/${target}.md
</code></pre>
<h2 id="organelle-file-arguments"><a class="header" href="#organelle-file-arguments">Organelle File Arguments</a></h2>
<p>Each organelle is a function and expects the following standardized interface for interoperability:</p>
<pre><code class="language-nix">{ inputs, cell }: {}
</code></pre>
<h2 id="the-inputs-argument"><a class="header" href="#the-inputs-argument">The <code>inputs</code> argument</a></h2>
<p>The <code>inputs</code> argument holds all the de-systemized flake inputs plus a few special inputs:</p>
<pre><code class="language-nix">{
  inputs = {
    self = {}; # sourceInfo of the current repository
    nixpkgs = {}; # an _instantiated_ nixpkgs
    cells = {}; # the other cells in this repo
  };
}
</code></pre>
<h2 id="the-cell-argument"><a class="header" href="#the-cell-argument">The <code>cell</code> argument</a></h2>
<p>The <code>cell</code> argument holds all the different organelle targets of the current cell.
This is the main mechanism by which code organization and separation of concern is enabled.</p>
<h2 id="the-desytemized-inputs"><a class="header" href="#the-desytemized-inputs">The <code>deSytemize</code>d inputs</a></h2>
<p>All inputs are scoped for the <em>current</em> system, that is derived from the <code>systems</code> input list to <code>std.grow</code>.
That means contrary to the usual nix-UX, in most cases, you don’t need to worry about <code>system</code>.</p>
<p>The current system will be “lifted up” one level, while still providing full access to all <code>systems</code> for
cross-compilation scenarios.</p>
<pre><code class="language-nix"># inputs.a.packages.${system}
{
  inputs.a.packages.pkg1 = {};
  inputs.a.packages.pkg2 = {};
  /* ... */
  inputs.a.packages.${system}.pkgs1 = {};
  inputs.a.packages.${system}.pkgs2 = {};
  /* ... */
}
</code></pre>
<h4 id="desystemizes-implementation"><a class="header" href="#desystemizes-implementation"><code>deSystemize</code>’s implementation</a></h4>
<pre><code class="language-nix">let
  l = builtins;
  /*
  A helper function which hides the complexities of dealing
  with 'system' properly from you, while still providing
  escape hatches when dealing with cross-compilation.

  You can use this function independently of the rest of std.
  */
  deSystemize = let
    iteration = cutoff: system: fragment:
      if ! (l.isAttrs fragment) || cutoff == 0
      then fragment
      else if l.hasAttr &quot;${system}&quot; fragment &amp;&amp; ! l.isFunction fragment.${system}
      then fragment // fragment.${system}
      else if l.hasAttr &quot;${system}&quot; fragment &amp;&amp; l.isFunction fragment.${system}
      then fragment // {__functor = _: fragment.${system};}
      else l.mapAttrs (_: iteration (cutoff - 1) system) fragment;
  in
    iteration 3;
in
  deSystemize
</code></pre>
<h2 id="top-level-system-scoping-of-outputs"><a class="header" href="#top-level-system-scoping-of-outputs">Top-level <code>system</code>-scoping of outputs</a></h2>
<p>Contrary to the upstream flake schema, all outputs are <code>system</code> spaced at the top-level.
This allows us to uniformly select on the <em>current</em> system and forget about it for most
of the time.</p>
<p>Sometimes <code>nix</code> evaluations don’t strictly depend on a particular <code>system</code>, and scoping
them seems counter-intuitive. But due to the fact that function calls are memoized, there
is never a penalty in actually scoping them. So for the sake of uniformity, we scope them
anyways.</p>
<p>The outputs therefore abide by the following “schema”:</p>
<pre><code class="language-nix">{
  ${system}.${cell}.${organelle}.${target} = {};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin-clades"><a class="header" href="#builtin-clades">Builtin Clades</a></h1>
<p>A few clades (“typed organelles”) are packaged with <code>std</code>.</p>
<p>In practical terms, clades distinguish themselves through the
actions they provide to a particular organelle.</p>
<p>It is entirely possible to define custom clades with custom
actions according to the needs of your project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data"><a class="header" href="#data">Data</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Data Clade for json serializable data.

  Available actions:
    - write
    - explore

  For all actions is true:
    Nix-proper 'stringContext'-carried dependency will be realized
    to the store, if present.
  */
  data = name: {
    inherit name;
    clade = &quot;data&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: let
      builder = [&quot;nix&quot; &quot;build&quot; &quot;--impure&quot; &quot;--json&quot; &quot;--no-link&quot; &quot;--expr&quot; expr];
      jq = [&quot;|&quot; &quot;${nixpkgs.legacyPackages.${system}.jq}/bin/jq&quot; &quot;-r&quot; &quot;'.[].outputs.out'&quot;];
      fx = [&quot;|&quot; &quot;xargs&quot; &quot;cat&quot; &quot;|&quot; &quot;${nixpkgs.legacyPackages.${system}.fx}/bin/fx&quot;];
      expr = l.strings.escapeShellArg ''
        let
          pkgs = (builtins.getFlake &quot;${nixpkgs.sourceInfo.outPath}&quot;).legacyPackages.${system};
          this = (builtins.getFlake &quot;${flake}&quot;).${fragment};
        in
          pkgs.writeTextFile {
            name = &quot;data.json&quot;;
            text = builtins.toJSON this;
          }
      '';
    in [
      {
        name = &quot;write&quot;;
        description = &quot;write to file&quot;;
        command = l.concatStringsSep &quot;\t&quot; (builder ++ jq);
      }
      {
        name = &quot;explore&quot;;
        description = &quot;interactively explore&quot;;
        command = l.concatStringsSep &quot;\t&quot; (builder ++ jq ++ fx);
      }
    ];
  };
in
  data
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Functions Clade for reusable nix functions that you would
  call elswhere in the code.

  Also use this for all types of modules and profiles, since they are
  implemented as functions.

  Consequently, there are no actions available for functions.
  */
  functions = name: {
    inherit name;
    clade = &quot;functions&quot;;
  };
in
  functions
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runnables"><a class="header" href="#runnables">Runnables</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Runnables Clade for targets that you want to
  make accessible with a 'run' action on the TUI.
  */
  runnables = name: {
    inherit name;
    clade = &quot;runnables&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;run&quot;;
        description = &quot;exec this target&quot;;
        command = ''
          nix run ${flake}#${fragment}
        '';
      }
    ];
  };
in
  runnables
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installables"><a class="header" href="#installables">Installables</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Installables Clade for targets that you want to
  make availabe for installation into the user's nix profile.

  Available actions:
    - install
    - upgrade
    - remove
    - build
    - bundle
    - bundleImage
    - bundleAppImage
  */
  installables = name: {
    inherit name;
    clade = &quot;installables&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;install&quot;;
        description = &quot;install this target&quot;;
        command = ''
          nix profile install ${flake}#${fragment}
        '';
      }
      {
        name = &quot;upgrade&quot;;
        description = &quot;upgrade this target&quot;;
        command = ''
          nix profile upgrade ${flake}#${fragment}
        '';
      }
      {
        name = &quot;remove&quot;;
        description = &quot;remove this target&quot;;
        command = ''
          nix profile remove ${flake}#${fragment}
        '';
      }
      {
        name = &quot;build&quot;;
        description = &quot;build this target&quot;;
        command = ''
          nix build ${flake}#${fragment}
        '';
      }
      {
        name = &quot;bundle&quot;;
        description = &quot;bundle this target&quot;;
        command = ''
          nix bundle --bundler github:Ninlives/relocatable.nix --refresh ${flake}#${fragment}
        '';
      }
      {
        name = &quot;bundleImage&quot;;
        description = &quot;bundle this target to image&quot;;
        command = ''
          nix bundle --bundler github:NixOS/bundlers#toDockerImage --refresh ${flake}#${fragment}
        '';
      }
      {
        name = &quot;bundleAppImage&quot;;
        description = &quot;bundle this target to AppImage&quot;;
        command = ''
          nix bundle --bundler github:ralismark/nix-appimage --refresh ${flake}#${fragment}
        '';
      }
    ];
  };
in
  installables
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microvms"><a class="header" href="#microvms">Microvms</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Microvms Clade for Microvm.nix - https://github.com/astro/microvm.nix

  Available actions:
    - microvm
  */
  substituters = &quot;--option extra-substituters https://microvm.cachix.org&quot;;
  keys = &quot;--option extra-trusted-public-keys microvm.cachix.org-1:oXnBc6hRE3eX5rSYdRyMYXnfzcCxC7yKPTbZXALsqys=&quot;;

  microvms = name: {
    inherit name;
    clade = &quot;microvms&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: let
      run = [&quot;nix&quot; &quot;run&quot; &quot;${flake}#${fragment}.config.microvm.runner&quot;];
    in [
      {
        name = &quot;microvm&quot;;
        description = &quot;exec this microvm&quot;;
        command =
          (l.concatStringsSep &quot;\t&quot; run)
          + &quot;.$(nix eval --json --option warn-dirty false\ &quot;
          + &quot;${flake}#${fragment}.config.microvm.hypervisor)&quot;
          + &quot;\ ${substituters} ${keys}&quot;;
      }
    ];
  };
in
  microvms
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devshells"><a class="header" href="#devshells">Devshells</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Devshells Clade for devShells.

  Available actions:
    - enter
  */
  devshells = name: {
    inherit name;
    clade = &quot;devshells&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;enter&quot;;
        description = &quot;enter this devshell&quot;;
        command = ''
          std_layout_dir=$PRJ_ROOT/.std
          profile_path=&quot;$std_layout_dir/${fragmentRelPath}&quot;
          mkdir -p &quot;$profile_path&quot;
          nix_args=(
            &quot;$PRJ_ROOT#${fragment}&quot;
            &quot;--no-update-lock-file&quot;
            &quot;--no-write-lock-file&quot;
            &quot;--no-warn-dirty&quot;
            &quot;--accept-flake-config&quot;
            &quot;--no-link&quot;
            &quot;--build-poll-interval&quot; &quot;0&quot;
            &quot;--builders-use-substitutes&quot;
          )
          nix build &quot;''${nix_args[@]}&quot; --profile &quot;$profile_path/shell-profile&quot;
          bash -c &quot;source $profile_path/shell-profile/env.bash; SHLVL=$SHLVL; __devshell-motd; exec $SHELL -i&quot;
        '';
      }
    ];
  };
in
  devshells
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containers"><a class="header" href="#containers">Containers</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Containers Clade for OCI-images built with nix2container.

  Available actions:
    - print-image
    - copy-to-registry
    - copy-to-podman
    - copy-to-docker
  */
  containers = name: {
    inherit name;
    clade = &quot;containers&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;print-image&quot;;
        description = &quot;print out the image name &amp; tag&quot;;
        command = ''
          echo
          echo &quot;$(nix eval --raw ${flake}#${fragment}.imageName):$(nix eval --raw ${flake}#${fragment}.imageTag)&quot;
        '';
      }
      {
        name = &quot;copy-to-registry&quot;;
        description = &quot;copy the image to its remote registry&quot;;
        command = ''
          nix run ${flake}#${fragment}.copyToRegistry
        '';
      }
      {
        name = &quot;copy-to-docker&quot;;
        description = &quot;copy the image to the local docker registry&quot;;
        command = ''
          nix run ${flake}#${fragment}.copyToDockerDaemon
        '';
      }
      {
        name = &quot;copy-to-podman&quot;;
        description = &quot;copy the image to the local podman registry&quot;;
        command = ''
          nix run ${flake}#${fragment}.copyToPodman
        '';
      }
    ];
  };
in
  containers
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nixago"><a class="header" href="#nixago">Nixago</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Nixago Clade for nixago pebbles.

  Use Nixago pebbles to ensure files are present
  or symlinked into your repository. You may typically
  use this for repo dotfiles.

  For more information, see: https://github.com/nix-community/nixago.

  Available actions:
    - ensure
    - explore

  */
  nixago = name: {
    inherit name;
    clade = &quot;nixago&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;populate&quot;;
        description = &quot;populate this nixago file into the repo&quot;;
        command = ''
          nix run ${flake}#${fragment}.install
        '';
      }
      {
        name = &quot;explore&quot;;
        description = &quot;interactively explore the nixago file&quot;;
        command = ''
          ${nixpkgs.legacyPackages.${system}.bat}/bin/bat &quot;$(nix build --no-link --print-out-paths ${flake}#${fragment}.configFile)&quot;
        '';
      }
    ];
  };
in
  nixago
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-cell"><a class="header" href="#the-std-cell">The <code>std</code> Cell</a></h1>
<p>… is the only cell in <code>divnix/std</code> and provides only very limited functionality.</p>
<ul>
<li>It contains the TUI, in <code>./cli</code>.</li>
<li>It contains a <code>devshellProfile</code> in <code>./devshellProfiles</code>.</li>
<li>It contains a growing number of second level library functions in <code>./lib</code>.</li>
<li>Packages that are used in std devshells are proxied in <code>./packages</code>.</li>
</ul>
<p>That’s it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-tui--cli"><a class="header" href="#the-std-tui--cli">The <code>std</code> TUI / CLI</a></h1>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<ul>
<li>Enter a <code>std</code>ized repository.</li>
<li>Enter it’s devshell (which must include <code>//std/devshellProfiles:default</code>)</li>
<li>Run <code>std</code>.</li>
</ul>
<p>It will show you around interactively and lead you very quickly to what you’re looking for.</p>
<p>It’s self-documented on it’s legend.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stds-devshellprofiles"><a class="header" href="#stds-devshellprofiles"><code>std</code>’s <code>devshellProfiles</code></a></h1>
<p>This organelle only exports a single <code>default</code> devshellProfile.</p>
<p>Any <code>std</code>ized repository should include this into its <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code></a>
in order to provide any visitor with the fully pre-configured <code>std</code> TUI.</p>
<p>It also wires &amp; instantiates a decent ADR tool. Or were you planning to hack away
without some minimal conscious effort of decision making and recording? 😅</p>
<h1 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h1>
<pre><code class="language-nix"># ./nix/automation/devshells.nix
{
  inputs,
  cell,
}: let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
  inherit (inputs.std) std;
in
  l.mapAttrs (_: std.lib.mkShell) {
    # `default` is a special target in newer nix versions
    # see: harvesting below
    default = {
      name = &quot;My Devshell&quot;;
      # make `std` available in the numtide/devshell
      imports = [ std.devshellProfiles.default ];
    };
  }
</code></pre>
<pre><code class="language-nix"># ./flake.nix
{
  inputs.std.url = &quot;github:divnix/std&quot;;

  outputs = inputs:
    inputs.std.growOn {
      inherit inputs;
      cellsFrom = ./nix;
      organelles = [
        /* ... */
        (inputs.std.clades.devshells &quot;devshells&quot;)
      ];
    }
    # soil for compatiblity ...
    {
      # ... with `nix develop` - `default` is a special target for `nix develop`
      devShells = inputs.std.harvest inputs.self [&quot;automation&quot; &quot;devshells&quot;];
    };
}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-library"><a class="header" href="#the-std-library">The <code>std</code> library</a></h1>
<p>This library may accumulate over time library functions that provide
integrations with other frameworks or are so overwhelmingly &amp; generally
useful that upstreaming them into Standard cannot be withheld.</p>
<p>In general, though, <code>std</code> is already opinionated enough in order to grow
this library very conservatively, only.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frommakeswith-provides-an-interface-to-makes-tasks"><a class="header" href="#frommakeswith-provides-an-interface-to-makes-tasks"><code>fromMakesWith</code> provides an interface to <code>makes</code> tasks</a></h1>
<p>This is an integration for <a href="https://github.com/fluidattacks/makes"><code>fluidattacks/makes</code></a>.</p>
<p>A version that has this <a href="https://github.com/fluidattacks/makes/commit/cd8c4eda69e2ce8dc6f811973ba0d80070b4628a">patch</a> is a prerequisite.</p>
<h2 id="usage-example-1"><a class="header" href="#usage-example-1">Usage example</a></h2>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  make = inputs.std.std.lib.fromMakesWith inputs;
in {
  task = make ./path/to/make/task//main.nix {};
}
</code></pre>
<p><em>Some refactoring of the tasks may be necessary. Let the error messages be your friend.</em></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="mkshell"><a class="header" href="#mkshell"><code>mkShell</code></a></h1>
<p>This is a transparent convenience proxy for <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code>’s</a> <code>mkShell</code> function.</p>
<p>It is enriched with a tight integration for <code>std</code> <a href="https://github.com/nix-community/nixago">Nixago</a> pebbles:</p>
<pre><code class="language-nix">{ inputs, cell}: {
  default = inputs.std.std.lib.mkShell {
    /* ... */
    nixago = [
      (cell.nixago.foo {
        configData.qux = &quot;xyz&quot;;
        packages = [ pkgs.additional-package ];
      })
      cell.nixago.bar
      cell.nixago.quz
    ];
  };
}
</code></pre>
<p><em>Note, that you can extend any Nixago Pebble at the calling site
via a built-in functor like in the example above.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writeshellentrypoint"><a class="header" href="#writeshellentrypoint"><code>writeShellEntrypoint</code></a></h1>
<p>… is a function to write Standard OCI-image entrypoints.</p>
<p>The function signature is as follows:</p>
<pre><code class="language-nix">{
  # the installable that is wrapped by this entrypoint (re-exported)
  package,
  # the literal bash string of the entrypoint that will be wrapped
  entrypoint,
  # initialize environment variables with these defaults
  env ? {},
  # runtime installables that the entrypoint or liveness/readiness probe uses (re-exported)
  runtimeInputs ? [],
  # domain specific debugging utilities (re-exported)
  debugInputs ? [],
  # domain specific liveness probe literal bash fragment (re-exported)
  livenessProbe ? null,
  # domain specific readiness probe literal bash fragment (re-exported)
  readinessProbe ? null,
}
</code></pre>
<p>It’s output wraps utility functions to generate size-optimized OCI-images:</p>
<pre><code class="language-nix">rec {
  entrypoint = std.std.lib.writeShellEntrypoint inputs { /* ... */ };
  oci-image = entrypoint.mkOCI &quot;docker.io/my-oci-image&quot;;
  oci-debug-image = entrypoint.mkDebugOCI &quot;docker.io/my-oci-image-debug&quot;;
}
</code></pre>
<h2 id="the-standard-image"><a class="header" href="#the-standard-image">The Standard Image</a></h2>
<p>Standard images are minimal and hardened. They only contain required dependencies.</p>
<h3 id="contracts"><a class="header" href="#contracts">Contracts</a></h3>
<p>The following contracts can be consumed:</p>
<pre><code>/bin/entrypoint # always present
/bin/runtime    # always present, drops into the runtime environment
/bin/live       # if livenessProbe was set
/bin/ready      # if readinessProbe was set
</code></pre>
<p>That’s it. There is nothing more to see.</p>
<p>All other dependencies are contained in <code>/nix/store/...</code>.</p>
<h2 id="the-debug-image"><a class="header" href="#the-debug-image">The Debug Image</a></h2>
<p>Debug Images wrap the standard images and provide additional debugging packages.</p>
<p>Hence, they are neither minimal, nor hardened because of the debugging packages’ added surface.</p>
<h3 id="contracts-1"><a class="header" href="#contracts-1">Contracts</a></h3>
<p>The following contracts can be consumed:</p>
<pre><code>/bin/entrypoint # always present
/bin/runtime    # always present, drops into the runtime environment
/bin/debug      # always present, drops into the debugging environment
/bin/live       # if livenessProbe was set
/bin/ready      # if readinessProbe was set
</code></pre>
<h2 id="how-to-extend"><a class="header" href="#how-to-extend">How to extend?</a></h2>
<p>A Standard or Debug Image doesn’t have a package manager available in the environment.</p>
<p>Hence, to extend the image you have two options:</p>
<h3 id="nix-based-extension"><a class="header" href="#nix-based-extension">Nix-based extension</a></h3>
<pre><code class="language-nix">rec {
  upstream = n2c.pullImage {
    imageName = &quot;docker.io/my-upstream-image&quot;;
    imageDigest = &quot;sha256:fffff.....&quot;;
    sha256 = &quot;sha256-ffffff...&quot;;
  };
  modified = n2c.buildImage {
    name = &quot;docker.io/my-modified-image&quot;;
    fromImage = upstream;
    contents = [nixpkgs.bashInteractive];
  };
}
</code></pre>
<h3 id="dockerfile-based-extension"><a class="header" href="#dockerfile-based-extension">Dockerfile-based extension</a></h3>
<pre><code class="language-Dockerfile">FROM alpine AS builder
RUN apk --no-cache curl

FROM docker.io/my-upstream-image
COPY --from=builder /... /

</code></pre>
<p><em>Please refer to the official dockerfile documentation for more details.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mknixago"><a class="header" href="#mknixago"><code>mkNixago</code></a></h1>
<p>This is a transparent convenience proxy for <a href="https://github.com/nix-community/nixago"><code>nix-community/nixago</code>’s</a> <code>lib.${system}.make</code> function.</p>
<p>It is enriched with a forward contract towards <code>std</code> enriched <code>mkShell</code> implementation.</p>
<p>In order to define <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code>’s</a> <code>commands</code> &amp; <code>packages</code> alongside the Nixago pebble,
just add the following attrset to the Nixago spec. It will be picked up automatically by <code>mkShell</code> when that pebble
is used inside its <code>config.nixago</code>-option.</p>
<pre><code class="language-nix">{ inputs, cell }: {
  foo = inputs.std.std.lib.mkNixago {
    /* ... */
    packages = [ /* ... */ ];
    commands = [ /* ... */ ];
    devshell = { /* ... */ }; # e.g. for startup hooks
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-nixago-pebbles"><a class="header" href="#the-std-nixago-pebbles">The <code>std</code> Nixago Pebbles</a></h1>
<p>Standard comes packages with some <a href="https://github.com/nix-community/nixago">Nixago</a> Pebbles for easy
downstream re-use.</p>
<p>Some Pebbles may have a special integration for <code>std</code>.</p>
<p>For example, the <code>conform</code> Pebble can undestand <code>inputs.cells</code>
and add each Cell as a so called “scope” to its
<a href="https://www.conventionalcommits.org/">Conventional Commit</a> configuration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adrgen"><a class="header" href="#adrgen"><a href="https://github.com/asiermarques/adrgen"><code>adrgen</code></a></a></h1>
<p>A great tool to manage Architecture Decision Records.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conform"><a class="header" href="#conform"><a href="https://github.com/siderolabs/conform"><code>conform</code></a></a></h1>
<p>Conform your code to policies, e.g. in a pre-commit hook.</p>
<p>This version is wrapped, it can auto-enhance the conventional
commit scopes with your <code>cells</code> as follows:</p>
<pre><code class="language-nix">{ inputs, cell}: let
  inherit (inputs.std) std;
in {

  default = std.lib.mkShell {
    /* ... */
    nixago = [
      (std.nixago.conform {configData = {inherit (inputs) cells;};})
    ];
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editorconfig"><a class="header" href="#editorconfig"><a href="https://github.com/editorconfig/"><code>editorconfig</code></a></a></h1>
<p>Most editors understand this file and autoconfigure themselves accordingly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lefthook"><a class="header" href="#lefthook"><a href="https://github.com/evilmartians/lefthook"><code>lefthook</code></a></a></h1>
<p>A fast (parallel execution) and elegant git hook manager.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook"><a class="header" href="#mdbook"><a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a></a></h1>
<p>Write clean docs for humans.</p>
<p>This version comes preset with this gem to make any
Solution Architect extra happy: <a href="https://github.com/joelcourtney/mdbook-kroki-preprocessor"><code>mdbook-kroki-preprocessor</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="treefmt"><a class="header" href="#treefmt"><a href="https://github.com/numtide/treefmt"><code>treefmt</code></a></a></h1>
<p>A code formatter to fromat the entire code tree extremly fast (in parallel and with a smart cache).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devshells-1"><a class="header" href="#devshells-1">Devshells</a></h1>
<ul>
<li>The <code>default</code> devshell implements the development environment for the <code>std</code> TUI/CLI.</li>
<li>Furthermore, it implements a <code>pre-commit</code> hook to keep the source code formatted.</li>
<li>It makes use of <code>std.lib.mkShell</code> which is a convenience proxy for <code>numtide/devshell</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p><strong>Cell</strong></p>
<p>: A Cell is the folder name of the first level under <code>${cellsFrom}</code>. They represent a coherent semantic collection of functionality.</p>
<p><strong>Organelle</strong></p>
<p>: An Organelle is the specific <em>named type</em> of a Standard (and hence: Flake) output.</p>
<p><strong>Clade</strong></p>
<p>: A Clade is the unnamed generic type of an Organelle and may or may not implement Clade Actions.</p>
<p><strong>Target</strong></p>
<p>: A Target is the actual output of an Organelle. If there is only one intended output, it is called <code>default</code> by convention.</p>
<p><strong>Action</strong></p>
<p>: An Action is a runnable procedure implemented on the generic Clade type. These are abstract procedures that are valuable in any concrete Organelle of such Clade.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="static/mermaid.min.js"></script>
        <script type="text/javascript" src="static/mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
