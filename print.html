<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Standard Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="tutorials/walk-in-the-park.html"><strong aria-hidden="true">1.</strong> A walk in the park</a></li><li class="chapter-item expanded "><a href="tutorials/hello-world/index.html"><strong aria-hidden="true">2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="tutorials/hello-moon/index.html"><strong aria-hidden="true">3.</strong> Hello Moon</a></li><li class="chapter-item expanded affix "><li class="part-title">How-To Guides</li><li class="chapter-item expanded "><a href="guides/growing-cells.html"><strong aria-hidden="true">4.</strong> Growing Cells</a></li><li class="chapter-item expanded "><a href="guides/incl.html"><strong aria-hidden="true">5.</strong> Include Filter</a></li><li class="chapter-item expanded "><a href="guides/envrc.html"><strong aria-hidden="true">6.</strong> Setup .envrc</a></li><li class="chapter-item expanded affix "><li class="part-title">Explanation</li><li class="chapter-item expanded "><a href="explain/why-nix.html"><strong aria-hidden="true">7.</strong> Why nix?</a></li><li class="chapter-item expanded "><a href="explain/why-std.html"><strong aria-hidden="true">8.</strong> Why std?</a></li><li class="chapter-item expanded "><a href="explain/architecture-decision-records/index.html"><strong aria-hidden="true">9.</strong> Architecture Decisions</a></li><li class="chapter-item expanded affix "><li class="part-title">Patterns</li><li class="chapter-item expanded "><a href="patterns/four-packaging-layers.html"><strong aria-hidden="true">10.</strong> The 4 Packaging Layers</a></li><li class="chapter-item expanded affix "><li class="part-title">Templates</li><li class="chapter-item expanded "><a href="templates/rust.html"><strong aria-hidden="true">11.</strong> Rust</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/cli.html"><strong aria-hidden="true">12.</strong> TUI/CLI</a></li><li class="chapter-item expanded "><a href="reference/conventions.html"><strong aria-hidden="true">13.</strong> Conventions</a></li><li class="chapter-item expanded "><a href="reference/deprecations.html"><strong aria-hidden="true">14.</strong> Deprecations</a></li><li class="chapter-item expanded "><a href="reference/blocktypes.html"><strong aria-hidden="true">15.</strong> Builtin Block Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/blocktypes/data-blocktype.html"><strong aria-hidden="true">15.1.</strong> Data</a></li><li class="chapter-item expanded "><a href="reference/blocktypes/functions-blocktype.html"><strong aria-hidden="true">15.2.</strong> Functions</a></li><li class="chapter-item expanded "><a href="reference/blocktypes/runnables-blocktype.html"><strong aria-hidden="true">15.3.</strong> Runnables</a></li><li class="chapter-item expanded "><a href="reference/blocktypes/installables-blocktype.html"><strong aria-hidden="true">15.4.</strong> Installables</a></li><li class="chapter-item expanded "><a href="reference/blocktypes/microvms-blocktype.html"><strong aria-hidden="true">15.5.</strong> Microvms</a></li><li class="chapter-item expanded "><a href="reference/blocktypes/devshells-blocktype.html"><strong aria-hidden="true">15.6.</strong> Devshells</a></li><li class="chapter-item expanded "><a href="reference/blocktypes/containers-blocktype.html"><strong aria-hidden="true">15.7.</strong> Containers</a></li><li class="chapter-item expanded "><a href="reference/blocktypes/nixago-blocktype.html"><strong aria-hidden="true">15.8.</strong> Nixago</a></li><li class="chapter-item expanded "><a href="reference/blocktypes/nomad-job-manifests-blocktype.html"><strong aria-hidden="true">15.9.</strong> Nomad Job Manifests</a></li></ol></li><li class="chapter-item expanded "><a href="reference/std/index.html"><strong aria-hidden="true">16.</strong> //std</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/std/cli/index.html"><strong aria-hidden="true">16.1.</strong> /cli</a></li><li class="chapter-item expanded "><a href="reference/std/devshellProfiles/index.html"><strong aria-hidden="true">16.2.</strong> /devshellProfiles</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/index.html"><strong aria-hidden="true">16.3.</strong> /nixago</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/std/nixago/adrgen.html"><strong aria-hidden="true">16.3.1.</strong> /adrgen</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/conform.html"><strong aria-hidden="true">16.3.2.</strong> /conform</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/editorconfig.html"><strong aria-hidden="true">16.3.3.</strong> /editorconfig</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/just.html"><strong aria-hidden="true">16.3.4.</strong> /just</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/lefthook.html"><strong aria-hidden="true">16.3.5.</strong> /lefthook</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/mdbook.html"><strong aria-hidden="true">16.3.6.</strong> /mdbook</a></li><li class="chapter-item expanded "><a href="reference/std/nixago/treefmt.html"><strong aria-hidden="true">16.3.7.</strong> /treefmt</a></li></ol></li><li class="chapter-item expanded "><a href="reference/std/errors/index.html"><strong aria-hidden="true">16.4.</strong> /errors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/std/errors/removeBy.html"><strong aria-hidden="true">16.4.1.</strong> /removeBy</a></li><li class="chapter-item expanded "><a href="reference/std/errors/requireInput.html"><strong aria-hidden="true">16.4.2.</strong> /requireInput</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reference/lib/index.html"><strong aria-hidden="true">17.</strong> //lib</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/lib/dev/index.html"><strong aria-hidden="true">17.1.</strong> /dev</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/lib/dev/mkMakes.html"><strong aria-hidden="true">17.1.1.</strong> /mkMakes</a></li><li class="chapter-item expanded "><a href="reference/lib/dev/mkShell.html"><strong aria-hidden="true">17.1.2.</strong> /mkShell</a></li><li class="chapter-item expanded "><a href="reference/lib/dev/mkNixago.html"><strong aria-hidden="true">17.1.3.</strong> /mkNixago</a></li></ol></li><li class="chapter-item expanded "><a href="reference/lib/ops/index.html"><strong aria-hidden="true">17.2.</strong> /ops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/lib/ops/mkMicrovm.html"><strong aria-hidden="true">17.2.1.</strong> /mkMicrovm</a></li><li class="chapter-item expanded "><a href="reference/lib/ops/mkOperable.html"><strong aria-hidden="true">17.2.2.</strong> /mkOperable</a></li><li class="chapter-item expanded "><a href="reference/lib/ops/mkOCI.html"><strong aria-hidden="true">17.2.3.</strong> /mkOCI</a></li><li class="chapter-item expanded "><a href="reference/lib/ops/mkStandardOCI.html"><strong aria-hidden="true">17.2.4.</strong> /mkStandardOCI</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="reference/presets/index.html"><strong aria-hidden="true">18.</strong> //presets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/presets/templates/index.html"><strong aria-hidden="true">18.1.</strong> /templates</a></li><li class="chapter-item expanded "><a href="reference/presets/nixago/index.html"><strong aria-hidden="true">18.2.</strong> /nixago</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/presets/nixago/adrgen.html"><strong aria-hidden="true">18.2.1.</strong> /adrgen</a></li><li class="chapter-item expanded "><a href="reference/presets/nixago/conform.html"><strong aria-hidden="true">18.2.2.</strong> /conform</a></li><li class="chapter-item expanded "><a href="reference/presets/nixago/editorconfig.html"><strong aria-hidden="true">18.2.3.</strong> /editorconfig</a></li><li class="chapter-item expanded "><a href="reference/presets/nixago/lefthook.html"><strong aria-hidden="true">18.2.4.</strong> /lefthook</a></li><li class="chapter-item expanded "><a href="reference/presets/nixago/mdbook.html"><strong aria-hidden="true">18.2.5.</strong> /mdbook</a></li><li class="chapter-item expanded "><a href="reference/presets/nixago/treefmt.html"><strong aria-hidden="true">18.2.6.</strong> /treefmt</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> //_automation</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/_automation/devshells/index.html"><strong aria-hidden="true">19.1.</strong> /devshells</a></li></ol></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">20.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Standard Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
SPDX-FileCopyrightText: 2022 The Standard Authors
SPDX-FileCopyrightText: 2022 Kevin Amado <kamadorueda@gmail.com>

SPDX-License-Identifier: Unlicense
-->
<div align="center">
  <img src="https://github.com/divnix/std/raw/main/artwork/logo.png" width="250" />
  <h1 id="standard"><a class="header" href="#standard">Standard</a></h1>
  <p>Ship today.</span>
</div>
<!--
_By [Kevin Amado](https://github.com/kamadorueda),
with contributions from [David Arnold](https://github.com/blaggacao),
[Timothy DeHerrera](https://github.com/nrdxp)
and many more amazing people (see end of file for a full list)._
-->
<p><a href="https://github.com/divnix/std">Standard</a> is THE opinionated, generic,
<a href="https://nixos.org/manual/nix/unstable">Nix</a> <a href="https://nixos.wiki/wiki/Flakes">Flakes</a> framework
that will allow you to grow and cultivate
Nix Cells with ease. Nix Cells are the fine
art of code organization using flakes.</p>
<p><em>Once</em> your <code>nix</code> code has evolved into a giant
ball of spaghetti and nobody else except a few
select members of your tribe can still read it
with ease; and <em>once</em> to the rest of your colleagues
it has grown into an impertinence, <em>then</em> <code>std</code>
brings the overdue order to your piece of art
through a well-defined folder structure and
disciplining generic interfaces.</p>
<p>With <code>std</code>, you’ll learn how to organize your <code>nix</code>
flake outputs (‘<strong>Targets</strong>’) into <strong>Cells</strong> and
<strong>Cell Blocks</strong> — folded into a useful
<strong>CLI &amp; TUI</strong> to also make the lives of your
colleagues easier.</p>
<p>Through more intuition and less documentation,
your team and community will finally find a
<em>canonical</em> answer to the everlasting question:
<em>What can I <strong>do</strong> with this repository?</em></p>
<hr />
<h2 id="the-std-repository-itself"><a class="header" href="#the-std-repository-itself">The <code>std</code> repository itself</a></h2>
<p>In this repository, you’ll find, both, the <em>implementation</em> and an <em>application</em> of <a href="https://github.com/divnix/std">Standard</a>.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p><em>What is <code>std</code>? — The well-commented <code>nix</code> code → <a href="https://github.com/divnix/std/tree/main/src"><code>./src</code></a>.</em></p>
<p>That folder implements:</p>
<ul>
<li><a href="https://github.com/divnix/std/blob/main/src/grow.nix"><code>std.grow</code></a>: the “smart” importer</li>
<li><a href="https://github.com/divnix/std/blob/main/src/grow-on.nix"><code>std.growOn</code></a>: <code>std.grow</code>-variant that recursively merges all additional variadic arguments</li>
<li><a href="https://github.com/divnix/std/blob/main/src/harvest.nix"><code>std.harvest</code></a>: harvest your <strong>Targets</strong> into a different shape for compatibility</li>
<li><a href="https://github.com/divnix/std/blob/main/src/winnow.nix"><code>std.winnow</code></a>: when more advanced harvesting is required, use this to harvest <em>and</em> filter the output</li>
<li><a href="https://github.com/divnix/std/blob/main/src/incl.nix"><code>std.incl</code></a>: a straight-forward source filter with additive semantics</li>
<li><a href="https://github.com/divnix/std/blob/main/src/de-systemize.nix"><code>std.deSystemize</code></a>: a helper to hide <code>system</code> from plain sight</li>
<li><a href="https://github.com/divnix/std/blob/main/src/blocktypes.nix"><code>std.&lt;blockType&gt;</code></a>: builtin <strong>(Cell) Block Types</strong> that implement <strong>(Cell Block Type) Actions</strong></li>
</ul>
<h3 id="application"><a class="header" href="#application">Application</a></h3>
<p><em>Dog-fooding? → <a href="https://github.com/divnix/std/tree/main/cells"><code>./cells</code></a>.</em></p>
<ul>
<li><strong>Cells:</strong> <a href="https://github.com/divnix/std/tree/main/cells"><code>./cells</code></a> mainly implements <a href="https://github.com/divnix/std/tree/main/cells/std"><code>std</code></a>.</li>
<li><strong>Cell Blocks:</strong> <a href="https://github.com/divnix/std/tree/main/cells/std"><code>std</code></a> implements:
<ul>
<li><a href="https://github.com/divnix/std/blob/main/cells/std/cli.nix"><code>cli</code></a>;</li>
<li><a href="https://github.com/divnix/std/blob/main/cells/std/devshellProfiles.nix"><code>devshellProfiles</code></a>;</li>
<li><a href="https://github.com/divnix/std/blob/main/cells/std/nixago.nix"><code>nixago</code></a>; and</li>
<li><a href="https://github.com/divnix/std/blob/main/cells/std/lib/default.nix"><code>lib</code></a>.</li>
</ul>
</li>
<li><strong>Targets:</strong> each Cell Block implements one or various targets.</li>
<li><strong>Block Type Actions:</strong> some <strong>Targets</strong> expose <strong>Actions</strong> inferred from the <strong>Block Type</strong>.</li>
</ul>
<pre><code class="language-nix">{
  growOn,
  inputs,
  blockTypes,
  harvest,
}:
growOn {
  inherit inputs;
  cellsFrom = ./cells;
  cellBlocks = [
    ## For downstream use

    # std
    (blockTypes.runnables &quot;cli&quot;)
    (blockTypes.functions &quot;devshellProfiles&quot;)
    (blockTypes.functions &quot;lib&quot;)
    (blockTypes.functions &quot;errors&quot;)
    (blockTypes.nixago &quot;nixago&quot;)
    (blockTypes.installables &quot;packages&quot;)

    # lib
    (blockTypes.functions &quot;dev&quot;)
    (blockTypes.functions &quot;ops&quot;)

    # presets
    (blockTypes.data &quot;templates&quot;)
    (blockTypes.nixago &quot;nixago&quot;)

    ## For local use in the Standard repository

    # _automation
    (blockTypes.devshells &quot;devshells&quot;)
    (blockTypes.nixago &quot;nixago&quot;)
    # (blockTypes.tasks &quot;tasks&quot;) # TODO: implement properly

    # _tests
    (blockTypes.data &quot;data&quot;)
    (blockTypes.files &quot;files&quot;)
  ];
} {
  devShells = harvest inputs.self [&quot;_automation&quot; &quot;devshells&quot;];
  packages = harvest inputs.self [[&quot;std&quot; &quot;cli&quot;] [&quot;std&quot; &quot;packages&quot;]];
  templates = let
    r = harvest inputs.self [&quot;presets&quot; &quot;templates&quot;];
    r' = builtins.head (builtins.attrNames r);
  in
    r.${r'};
}
</code></pre>
<p><em>That’s it. <code>std.grow</code> is a “smart” importer of your <code>nix</code> code and is designed to keep boilerplate at bay.</em></p>
<blockquote>
<p><strong>TIP:</strong>
Now, enter the devshell (<code>direnv allow</code>) and play with the <code>std</code> CLI/TUI companion.
It answers one critical question to newcomers and veterans alike:</p>
<center><i>What can I <b>do</b> with this repository?</i></center>
&emsp;
</blockquote>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<p><em>Where can I find the documentation? → <a href="https://github.com/divnix/std/tree/main/docs"><code>./docs</code></a>.</em></p>
<p><em>No, I mean rendered? → <a href="https://std.divnix.com">The Standard Book</a>.</em></p>
<p>The documentation is structured around these axes:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>For Study</th><th>For Work</th></tr></thead><tbody>
<tr><td><strong>The Practice</strong></td><td>Tutorials</td><td>How-To Guides</td></tr>
<tr><td><strong>The Theory</strong></td><td>Explanation</td><td>Reference</td></tr>
</tbody></table>
</div>
<h3 id="licenses"><a class="header" href="#licenses">Licenses</a></h3>
<p><em>What licenses are used? → <a href="https://github.com/divnix/std/blob/main/.reuse/dep5"><code>./.reuse/dep5</code></a>.</em></p>
<p><em>And the usual copies? → <a href="https://github.com/divnix/std/tree/main/LICENSES"><code>./LICENSES</code></a>.</em></p>
<h2 id="releases"><a class="header" href="#releases">Releases</a></h2>
<p>You may find releases on the <a href="https://github.com/divnix/std/releases">GitHub Release Page</a> of this repository.</p>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<ul>
<li><a href="https://std.divnix.com/explain/why-nix.html">Why <code>nix</code>?</a></li>
<li><a href="https://std.divnix.com/explain/why-std.html">Why <code>std</code>?</a></li>
</ul>
<h2 id="examples-in-the-wild"><a class="header" href="#examples-in-the-wild">Examples in the Wild</a></h2>
<p>If you’d like to see some examples
of what a <a href="https://github.com/divnix/std">Standard</a> project looks like,
take a look at the following:</p>
<ul>
<li><a href="https://github.com/input-output-hk/bitte-cells"><code>input-output-hk/bitte-cells</code></a></li>
<li><a href="https://github.com/divnix/hive"><code>divnix/hive</code></a></li>
<li><a href="https://github.com/input-output-hk/tullia"><code>input-output-hk/tullia</code></a></li>
<li><a href="https://github.com/input-output-hk/mdbook-kroki-preprocessor"><code>mdbook-kroki-preprocessor</code></a></li>
<li><a href="https://github.com/hardenedlinux/HardenedNixOS-Profile"><code>HardenedNixOS-Profile</code></a></li>
<li><a href="https://github.com/JuliaCN/Julia2Nix.jl"><code>Julia2Nix.jl</code></a></li>
<li><a href="https://github.com/input-output-hk/cardano-world"><code>inputs-output-hk/cardano-world</code></a></li>
</ul>
<p>:construction: Work in progress, would like to help us extend this section?</p>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Please enter the development environment:</p>
<pre><code class="language-console">direnv allow
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-walk-in-the-park"><a class="header" href="#a-walk-in-the-park">A walk in the park</a></h1>
<p>This is an excellent tutorial series by Joshua Gilman on his blog.</p>
<p>It is ideal for people with prior Nix and Nix Flakes experience.</p>
<p>They are written in a way that feels like a walk in the park, hence the nickname.</p>
<p>Enjoy!</p>
<hr />
<ol>
<li><a href="https://blog.jmgilman.com/an-introduction-to-nix-std/">Introduction to the Nix std Framework</a></li>
<li><a href="https://blog.jmgilman.com/development-shells-with-nix-std/">Development Shells with the Nix std Framework</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p><a href="https://github.com/divnix/std">Standard</a> features a special project structure
that brings some awesome innovation
to this often overlooked (but important) part of your project.
With the default <strong>Cell Blocks</strong>, an <code>apps.nix</code> file tells <a href="https://github.com/divnix/std">Standard</a>
that we are creating an Application.
<code>flake.nix</code> is in charge
of explicitly defining
the inputs of your project.</p>
<h4 id="flakenix"><a class="header" href="#flakenix"><code>./flake.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;
  inputs.nixpkgs.url = &quot;nixpkgs&quot;;

  outputs = {std, ...} @ inputs:
    std.grow {
      inherit inputs;
      cellsFrom = ./cells;
    };
}
</code></pre>
<h4 id="cellshelloappsnix"><a class="header" href="#cellshelloappsnix"><code>./cells/hello/apps.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: {
  default = inputs.nixpkgs.stdenv.mkDerivation rec {
    pname = &quot;hello&quot;;
    version = &quot;2.10&quot;;
    src = inputs.nixpkgs.fetchurl {
      url = &quot;mirror://gnu/hello/${pname}-${version}.tar.gz&quot;;
      sha256 = &quot;0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i&quot;;
    };
  };
}
</code></pre>
<pre><code class="language-bash">$ cd hello-world
# fetch `std`
$ nix shell github:divnix/std
$ std //hello/apps/default:run
Hello, world!
</code></pre>
<p>You see? from nothing
to running your first application
in just a few seconds ✨</p>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>This example consumes the following defaults or builtins:</p>
<h3 id="default-cellblocks"><a class="header" href="#default-cellblocks"><a href="https://github.com/divnix/std/blob/main/src/grow.nix#L63-L67">Default <code>cellBlocks</code></a></a></h3>
<pre><code class="language-nix">    organelles ? null,
    cellBlocks ? [
      (blockTypes.functions &quot;library&quot;)
      (blockTypes.runnables &quot;apps&quot;)
      (blockTypes.installables &quot;packages&quot;)
</code></pre>
<h3 id="default-systems"><a class="header" href="#default-systems"><a href="https://github.com/divnix/std/blob/main/src/grow.nix#L68-L77">Default <code>systems</code></a></a></h3>
<pre><code class="language-nix">    ],
    systems ? [
      # Tier 1
      &quot;x86_64-linux&quot;
      # Tier 2
      &quot;aarch64-linux&quot;
      &quot;x86_64-darwin&quot;
      # Other platforms with sufficient support in stdenv which is not formally
      # mandated by their platform tier.
      &quot;aarch64-darwin&quot; # a lot of apple M1 already out there
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-moon"><a class="header" href="#hello-moon">Hello Moon</a></h1>
<p><em>A slightly more complete <a href="tutorials/hello-moon/../hello-world">hello world</a> tutorial.</em></p>
<p>This tutorial implements a very typical <code>_automation</code> Cell and its Cell Blocks for a somewhat bigger project.
It also makes use of more advanced functions of <code>std</code>.
Namely:</p>
<ul>
<li><code>std.growOn</code> instead of <code>std.grow</code></li>
<li><code>std.harvest</code> to provide compatibility layers of “soil”</li>
<li>non-default Cell Block definitions</li>
<li>the input debug facility</li>
</ul>
<p>The terms <em>“Block Type”</em>, <em>“Cell”</em>, <em>“Cell Block”</em>, <em>“Target”</em> and <em>“Action”</em> have special meaning within the context of <code>std</code>.
With these clear definitions, we navigate and communicate the code structure much more easily.
In order to familiarize yourself with them, please have a quick glance at the <a href="tutorials/hello-moon/../../glossary.html">glossary</a>.</p>
<h2 id="file-layout"><a class="header" href="#file-layout">File Layout</a></h2>
<p>Let’s start again with a flake:</p>
<h4 id="flakenix-1"><a class="header" href="#flakenix-1"><code>./flake.nix</code></a></h4>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;
  inputs.nixpkgs.url = &quot;nixpkgs&quot;;

  outputs = {std, ...} @ inputs:
  /*
  brings std attributes into scope
  namely used here: `growOn`, `harvest` &amp; `blockTypes`
  */
    with std;
    /*
    grows a flake &quot;from cells&quot; on &quot;soil&quot;; see below...
    */
      growOn {
        /*
        we always inherit inputs and expose a deSystemized version
        via {inputs, cell} during import of Cell Blocks.
        */
        inherit inputs;

        /*
        from where to &quot;grow&quot; cells?
        */
        cellsFrom = ./nix;

        /*
        custom Cell Blocks (i.e. &quot;typed outputs&quot;)
        */
        cellBlocks = [
          (blockTypes.devshells &quot;devshells&quot;)
          (blockTypes.nixago &quot;nixago&quot;)
        ];

        /*
        This debug facility helps you to explore what attributes are available
        for a given input untill you get more familiar with `std`.
        */
        debug = [&quot;inputs&quot; &quot;std&quot;];
      }
      /*

      Soil is an idiom to refer to compatibility layers that are recursively
      merged onto the outputs of the `std.grow` function.

      */
      # Soil ...
      # 1) layer for compat with the nix CLI
      {
        devShells = harvest inputs.self [&quot;_automation&quot; &quot;devshells&quot;];
      }
      # 2) there can be various layers; `growOn` is a variadic function
      {};
}
</code></pre>
<p>This time we specified <code>cellsFrom = ./nix;</code>.
This is gentle so that our colleagues know immediately which files to either look or never look at depending on where they stand.</p>
<p>We also used <code>std.growOn</code> instead of <code>std.grow</code> so that we can add compatibility layers of “soil”.</p>
<p>Furthermore, we only defined two Cell Blocks: <code>nixago</code> &amp; <code>devshells</code>. More on them follows…</p>
<h4 id="nix_automation"><a class="header" href="#nix_automation"><code>./nix/_automation/*</code></a></h4>
<p>Next, we define a <code>_automation</code> cell.
Each project will have some amount of automation.
This can be repository automation, such as code generation.
Or it can be a CI/CD specification.
In here, we wire up two tools from the Nix ecosystem: <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code></a> &amp; <a href="https://github.com/nix-community/nixago"><code>nix-community/nixago</code></a>.</p>
<blockquote>
<p><em>Please refer to these links to get yourself a quick overview before continuing this tutorial, in case you don’t know them, yet.</em></p>
<p>A <em>very</em> short refresher:</p>
<ul>
<li><strong>Nixago</strong>: Template &amp; render repository (dot-)files with nix. <a href="tutorials/hello-moon/../../explain/why-nix.html">Why nix?</a></li>
<li><strong>Devshell</strong>: Friendly &amp; reproducible development shells — the original ™.</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Some semantic background:</strong></p>
<p>Both, Nixago &amp; Devshell are <em>Component Tools</em>.</p>
<p><em>(Vertical) Component Tools</em> are distinct from <em>(Horizontal) Integration Tools</em> — such as <code>std</code> — in that they provide a specific capability in a minimal linux style: <em>“Do one thing and do it well.”</em></p>
<p>Integration Tools however combine them into a polished user story and experience.</p>
<p>The Nix ecosystem is very rich in <em>component tools</em>, however only few <em>integration tools</em> exist at the time of writing.</p>
</blockquote>
<h4 id="nix_automationdevshellsnix"><a class="header" href="#nix_automationdevshellsnix"><code>./nix/_automation/devshells.nix</code></a></h4>
<p>Let’s start with the <code>cell.devshells</code> Cell Block and work our way backwards to the <code>cell.nixago</code> Cell Block below.</p>
<blockquote>
<p><strong>More semantic background:</strong></p>
<p>I could also reference them as <code>inputs.cells._automation.devshells</code> &amp; <code>inputs.cells._automation.nixago</code>.</p>
<p>But, because we are sticking with the local Cell context, we don’t want to confuse the future code reader.
Instead, we gently hint at the locality by just referring them via the <code>cell</code> context.</p>
</blockquote>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  /*
  I usually just find it very handy to alias all things library onto `l`...
  The distinction between `builtins` and `nixpkgs.lib` has little practical
  relevance, in most scenarios.
  */
  l = nixpkgs.lib // builtins;

  /*
  It is good practice to in-scope:
  - inputs by *name*
  - other Cells by their *Cell names*
  - the local Cell Blocks by their *Block names*.

  However, for `std`, we make an exeption and in-scope, despite being an
  input, its primary Cell with the same name as well as the dev lib.
  */
  inherit (inputs) nixpkgs;
  inherit (inputs.std) std;
  inherit (inputs.std.lib) dev;
  inherit (cell) nixago;
in
  # we use Standard's mkShell wrapper for its Nixago integration
  l.mapAttrs (_: dev.mkShell) {
    default = {...}: {
      name = &quot;My Devshell&quot;;
      # This `nixago` option is a courtesy of the `std` horizontal
      # integration between Devshell and Nixago
      nixago = [
        # off-the-shelve from `std`
        (std.nixago.conform {configData = {inherit (inputs) cells;};})
        std.nixago.lefthook
        std.nixago.adrgen
        # modified from the local Cell
        nixago.treefmt
        nixago.editorconfig
        nixago.mdbook
      ];
      # Devshell handily represents `commands` as part of
      # its Message Of The Day (MOTD) or the built-in `menu` command.
      commands = [
        {
          package = nixpkgs.reuse;
          category = &quot;legal&quot;;
          /*
          For display, reuse already has both a `pname` &amp; `meta.description`.
          Hence, we don't need to inline these - they are autodetected:

          name = &quot;reuse&quot;;
          description = &quot;Reuse is a tool to manage a project's LICENCES&quot;;
          */
        }
      ];
      # Always import the `std` default devshellProfile to also install
      # the `std` CLI/TUI into your Devshell.
      imports = [std.devshellProfiles.default];
    };
  }
</code></pre>
<p>The <code>nixago = [];</code> option in this definition is a special integration provided by the <a href="tutorials/hello-moon/../../reference/lib/dev/mkShell.html">Standard’s <code>devshell</code>-wrapper (<code>std.lib.mkShell</code>)</a>.</p>
<p><em>This is how <code>std</code> delivers on its promise of being a (horizontal) integration tool that wraps (vertical) component tools into a polished user story and experience.</em></p>
<p>Because we made use of <code>std.harvest</code> in the flake, you now can actually test out the devshell via the Nix CLI compat layer by just running <code>nix develop -c &quot;$SHELL&quot;</code> in the directory of the flake.
For a more elegant method of entering a development shell read on the <a href="tutorials/hello-moon/index.html#direnv">direnv</a> section below.</p>
<h4 id="nix_automationnixagonix"><a class="header" href="#nix_automationnixagonix"><code>./nix/_automation/nixago.nix</code></a></h4>
<p>As we have seen above, the <code>nixago</code> option in the <code>cell.devshells</code> Cell Block references Targets from both <code>std.nixago</code> <em>and</em> <code>cell.nixago</code>.
While you can explore <code>std.nixago</code> <a href="https://github.com/divnix/std/blob/main/cells/std/nixago.nix">here</a>, let’s now have a closer look at <code>cell.nixago</code>:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  inherit (inputs.std) std;
  /*
  While these are strictly specializations of the available
  Nixago Pebbles at `std.nixago.*`, it would be entirely
  possible to define a completely new pebble inline
  */
in {
  /*
  treefmt: https://github.com/numtide/treefmt
  */
  treefmt = std.nixago.treefmt {
    # we use the configData attribute to modify the
    # target data structure via a simple data overlay
    # (`divnix/data-merge` / `std.dmerge`) mechanism.
    configData.formatter.go = {
      command = &quot;gofmt&quot;;
      options = [&quot;-w&quot;];
      includes = [&quot;*.go&quot;];
    };
    # for the `std.lib.dev.mkShell` integration with nixago,
    # we also hint which packages should be made available
    # in the environment for this &quot;Nixago Pebble&quot;
    packages = [nixpkgs.go];
  };

  /*
  editorconfig: https://editorconfig.org/
  */
  editorconfig = std.nixago.editorconfig {
    configData = {
      # the actual target data structure depends on the
      # Nixago Pebble, and ultimately, on the tool to configure
      &quot;*.xcf&quot; = {
        charset = &quot;unset&quot;;
        end_of_line = &quot;unset&quot;;
        insert_final_newline = &quot;unset&quot;;
        trim_trailing_whitespace = &quot;unset&quot;;
        indent_style = &quot;unset&quot;;
        indent_size = &quot;unset&quot;;
      };
      &quot;{*.go,go.mod}&quot; = {
        indent_style = &quot;tab&quot;;
        indent_size = 4;
      };
    };
  };

  /*
  mdbook: https://rust-lang.github.io/mdBook
  */
  mdbook = std.nixago.mdbook {
    configData = {
      book.title = &quot;The Standard Book&quot;;
    };
  };
}
</code></pre>
<p>In this Cell Block, we have been modifying some built-in convenience <code>std.nixago.*</code> pebbles.
The way <code>configData</code> is merged upon the existing pebble is via a simple left-hand-side/right-hand-site <code>data-merge</code> (<code>std.dmerge</code>).</p>
<blockquote>
<p><strong>Background on array merge strategies:</strong></p>
<p>If you know how a plain data-merge (does not magically) deal with array merge semantics, you noticed:
We didn’t have to annotate our right-hand-side arrays in this example because we where not actually amending or modifying any left-hand-site array type data structure.</p>
<p>Would we have done so, we would have had to annotate:</p>
<ul>
<li>either with <code>std.dmerge.append [/* ... */]</code>;</li>
<li>or with <code>std.dmerge.update [ idx ] [/* ... */]</code>.</li>
</ul>
<p>But lucky us (this time)!</p>
</blockquote>
<h2 id="command-line-synthesis"><a class="header" href="#command-line-synthesis">Command Line Synthesis</a></h2>
<p>With this configuration in place, you have a couple of options on the command line.
Note, that you can accessor any <code>std</code> cli invocation also via the <code>std</code> TUI by just typing <code>std</code>.
Just in case you forgot exactly how to accessor one of these repository capabilities.</p>
<blockquote>
<p><strong>Debug Facility:</strong></p>
<p>Since the debug facility is enabled, you will see some trace output while running these commands.
To switch this off, just comment the <code>debug = [ /* ... */ ];</code> attribute in the flake.</p>
<p>It looks something like this:</p>
<pre><code class="language-nix">trace: inputs on x86_64-linux
trace: {
  cells = {…};
  nixpkgs = {…};
  self = {…};
  std = {…};
}
</code></pre>
</blockquote>
<p><strong>Invoke devshell via <code>nix</code></strong></p>
<pre><code class="language-bash">nix develop -c &quot;$SHELL&quot;
</code></pre>
<p>By quirks of the Nix CLI, if you don’t specify <code>-c &quot;$SHELL&quot;</code>, you’ll be thrown into an unfamiliar bare <code>bash</code> interactive shell.
That’s not what you want.</p>
<p><strong>Invoke the devshell via <code>std</code></strong></p>
<p>In this case, invoking <code>$SHELL</code> correctly is taken care for you by the Block Type’s <code>enter</code> Action.</p>
<pre><code class="language-bash"># fetch `std`
$ nix shell github:divnix/std
$ std //_automation/devshells/default:enter
</code></pre>
<p>Since we have declared the devshell Cell Block as a <code>blockTypes.devshells</code>, <code>std</code> auments it’s Targets with the Block Type Actions.</p>
<p>See <a href="tutorials/hello-moon/../../reference/blocktypes/devshells-blocktype.html"><code>blockTypes.devshells</code></a> for more details on the available Actions and their implementation.</p>
<p>Thanks to the <code>cell.devshells</code>’ <code>nixago</code> option, entering the devshell will also automatically reconcile the repository files under Nixago’s management.</p>
<p><strong>Explore a Nixago Pebble via <code>std</code></strong></p>
<p>You can also explore the nixago configuration via the Nixago Block Type’s <code>explore</code>-Action.</p>
<pre><code class="language-bash"># fetch `std`
$ nix shell github:divnix/std
$ std //_automation/nixago/treefmt:explore
</code></pre>
<p>See <a href="tutorials/hello-moon/../../reference/blocktypess/nixago-blocktype.html"><code>blockTypes.nixago</code></a> for more details on the available Actions and their implementation.</p>
<h2 id="direnv"><a class="header" href="#direnv">direnv</a></h2>
<p>Manually entering the devshell is boring.
How about a daemon always does that automatically &amp; efficiently when you <code>cd</code> into a project directory?
Enter <a href="https://direnv.net"><code>direnv</code></a> — the original (again; and even from the same author) 😊.</p>
<p>Before you continue, first install direnv according to it’s <a href="https://direnv.net/docs/installation.html">install instructions</a>.
It’s super simple &amp; super useful ™ and you should do it <em>right now</em> if you haven’t yet.</p>
<p>Please learn how to enable <code>direnv</code> in this project by following the <a href="tutorials/hello-moon/../../guides/envrc.html">direnv how-to</a>.</p>
<p>In this case, you would adapt the relevant line to: <strong><code>use std nix //_automation/devshells:default</code></strong>.</p>
<p>Now, you can simply <code>cd</code> into that directory, and the devshells is being loaded.
The MOTD will be shown, too.</p>
<p>The first time, you need to teach the <code>direnv</code> daemon to trust the <code>.envrc</code> file via <code>direnv allow</code>.
If you want to reload the devshell (e.g. to reconcile Nixago Pebbles), you can just run <code>direnv reload</code>.</p>
<p>Because I use these commands so often, I’ve set: <code>alias d=&quot;direnv&quot;</code> in my shell’s RC file.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="growing-cells"><a class="header" href="#growing-cells">Growing Cells</a></h1>
<p>Growing cells can be done via two variants:</p>
<ul>
<li><code>std.grow { cellsFrom = &quot;...&quot;; /* ... */ }</code></li>
<li><code>std.growOn { cellsFrom = &quot;...&quot;; /* ... */ } # soil</code></li>
</ul>
<h2 id="stdgrowon---soil"><a class="header" href="#stdgrowon---soil"><code>std.growOn {} # soil</code></a></h2>
<p>This eases talking and reasoning about a <code>std</code>ized repository, that also needs
some sort of adapters to work together better with external frameworks.</p>
<p>Typically, you’d arrange those adapters in numbered layers of soil, just
so that it’s easier to conceptually reference them when talking / chatting.</p>
<p>It’s a variadic function and takes an unlimited number of “soil layers”.</p>
<pre><code class="language-nix">{
  inputs.std.url = &quot;github:divnix/std&quot;;

  outputs = {std, ...} @ inputs:
    std.growOn {
      inherit inputs;
      cellsFrom = ./cells;
    }
    # soil
    () # first layer
    () # second layer
    () # ... nth layer
    ;
}
</code></pre>
<p>These layers get recursively merged onto the output of <code>std.grow</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="include-filter"><a class="header" href="#include-filter">Include Filter</a></h1>
<p>It is very common that you want to filter your source code in order
to avoid unnecessary rebuilds and increase your cache hits.</p>
<p>This is so common that <code>std</code> includes a tool for this:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  inherit (inputs) std;
in {
  backend = nixpkgs.mkYarnPackage {
    name = &quot;backend&quot;;
    src = std.incl (inputs.self + /src/backend) [
      (inputs.self + /src/backend/app.js)
      (inputs.self + /src/backend/config/config.js)
      /* ... */
    ];
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-envrc"><a class="header" href="#setup-envrc">Setup <code>.envrc</code></a></h1>
<p>Standard provides an extension to the <code>stdlib</code> via <code>direnv_lib.sh</code>.</p>
<p>The integrity hash below ensures it is downloaded only once and cached
from there on.</p>
<pre><code class="language-bash">#! /bin/sh

# SPDX-FileCopyrightText: 2022 David Arnold &lt;dgx.arnold@gmail.com&gt;
# SPDX-FileCopyrightText: 2022 Kevin Amado &lt;kamadorueda@gmail.com&gt;
#
# SPDX-License-Identifier: Unlicense

source &quot;$(
  nix eval \
  --no-update-lock-file \
  --no-write-lock-file \
  --no-warn-dirty \
  --accept-flake-config \
  .#__std.direnv_lib 2&gt;/dev/null
)&quot;
use std cells //_automation/devshells:default
</code></pre>
<blockquote>
<p><strong>NOTE:</strong>
In the above code <code>use std</code> <strong><code>cells</code></strong> <code>//std/...</code> refers to the
folder where <strong>Cells</strong> are grown from. If your folder is e.g. <code>nix</code>, adapt
to <code>use std</code> <strong><code>nix</code></strong> <code>//...</code> and so forth.</p>
</blockquote>
<p>It is used to automatically set up file watches on files that could modify the
current devshell, discoverable through these or similar logs during loading:</p>
<pre><code class="language-console">direnv: loading https://raw.githubusercontent.com/divnix/std/...
direnv: using std cells //_automation/devshells:default
direnv: Watching: cells/_automation/devshells.nix
direnv: Watching: cells/_automation/devshells (recursively)
</code></pre>
<p>For reference, the above example loads the <code>default</code> devshell from:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
  inherit (inputs.cells) std;
in
  l.mapAttrs (_: std.lib.mkShell) rec {
    default = {...}: {
      name = &quot;Standard&quot;;
      nixago = [
        (std.nixago.conform {configData = {inherit (inputs) cells;};})
        cell.nixago.treefmt
        cell.nixago.editorconfig
        cell.nixago.just
        std.nixago.lefthook
        std.nixago.adrgen
      ];
      commands =
        [
          {
            package = nixpkgs.reuse;
            category = &quot;legal&quot;;
          }
          {
            package = nixpkgs.delve;
            category = &quot;cli-dev&quot;;
            name = &quot;dlv&quot;;
          }
          {
            package = nixpkgs.go;
            category = &quot;cli-dev&quot;;
          }
          {
            package = nixpkgs.gotools;
            category = &quot;cli-dev&quot;;
          }
          {
            package = nixpkgs.gopls;
            category = &quot;cli-dev&quot;;
          }
        ]
        ++ l.optionals nixpkgs.stdenv.isLinux [
          {
            package = nixpkgs.golangci-lint;
            category = &quot;cli-dev&quot;;
          }
        ];
      imports = [std.devshellProfiles.default book];
    };

    book = {...}: {
      nixago = [cell.nixago.mdbook];
    };

    checks = {...}: {
      name = &quot;checks&quot;;
      imports = [std.devshellProfiles.default];
      commands = [
        {
          name = &quot;blocktype-data&quot;;
          command = &quot;cat $(std //_tests/data/example:write)&quot;;
        }
        {
          name = &quot;blocktype-devshells&quot;;
          command = &quot;std //_automation/devshell/default:enter -- echo OK&quot;;
        }
        {
          name = &quot;blocktype-runnables&quot;;
          command = &quot;std //std/cli/default:run -- std OK&quot;;
        }
      ];
    };
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-nix"><a class="header" href="#why-nix">Why <code>nix</code>?</a></h1>
<p>A lot of people write a lot of confusing stuff about nix.</p>
<p>So here, we’ll try to break it down, instead.</p>
<h2 id="nix-is-json-on-steroids"><a class="header" href="#nix-is-json-on-steroids"><code>nix</code> is “<code>json</code> on steroids”</a></h2>
<p>In configuration management, you have a choice: data vs. language.</p>
<p>On stackoverflow, you’ll be taught the “data” stance, because it’s simple.</p>
<p>And all of a sudden you hit reality. Outside of a “lab” environment, you suddenly
need to manage a varying degree of complexity.</p>
<p>So you need configuration combinators, or in other words a full blown language
to efficiently render your configurations.</p>
<p>There are a couple of options, that you’ll recognize if you’ve gotten serious about
the configuration challenge, like:</p>
<ul>
<li><a href="https://dhall-lang.org/"><code>dhall</code></a></li>
<li><a href="https://cuelang.org/"><code>cue</code></a></li>
<li><a href="https://jsonnet.org/"><code>jsonnet</code></a></li>
<li><a href="https://nickel-lang.org/"><code>nickel</code></a></li>
</ul>
<p>And there is <a href="https://nixos.org/"><code>nix</code></a>, the language. In most aspects, it isn’t hugely distinct from the others,
but it has superpowers. Read on!</p>
<h2 id="nix-superpowers"><a class="header" href="#nix-superpowers"><code>nix</code>’ superpowers</a></h2>
<p>You know the concept of string interpolation.</p>
<p>Every time <code>nix</code> interpolates an identifier, there is something that
you don’t immediately see: it keeps a so called “string context” right
at the site of interpolation. That string context holds a directed acyclic
graph of all the dependencies that are required to make that string.</p>
<p>“Well, it’s just a string; what on earth should I need to make a string?”, you may say.</p>
<p>There is a special category of strings, so called “Nix store paths”
(strings that start with <code>/nix/store/...</code>). These store paths represent
build artifacts that are content addressed ahead-of-time through
the inputs of an otherwise pure build function, called <a href="https://nixos.org/manual/nix/stable/expressions/derivations.html"><code>derivation</code></a>.</p>
<p>When you finally reify (i.e. “build”) your string interpolation, then all these Nix store
paths get build as well.</p>
<p>This might be a bit of a mind-boggling angle, but after a while, you may realize:</p>
<ul>
<li>Nix is a massive build pipeline that tracks all things to their source.</li>
<li>In their capacity as <em>pure</em> build functions, <a href="https://nixos.org/manual/nix/stable/expressions/derivations.html"><code>derviation</code>s</a> build <em>reproducibly</em>.</li>
<li>Reproducible builds are the future of software supply chain security, among other things.</li>
<li>You’ll start asking: “who the heck invented all that insecure nonsense of opaque binary registries?
Shouldn’t have those smart people have known better?”</li>
<li>And from this realization, there’s no coming back.</li>
<li>And you’ll have joined the <a href="https://discourse.nixos.org/t/nixos-foundation-participating-in-eus-next-generation-internet-initiative/2011">European Union</a>, <a href="https://discourse.nixos.org/t/mercury-bank-nix-engineers/13784">banks</a> and <a href="https://github.com/input-output-hk/cardano-world">blockchain companies</a> who also realized:
we need to fix our utterly broken and insecure build systems!</li>
<li>By that time, you’ll have already assimilated the legendary <a href="http://users.ece.cmu.edu/%7Eganger/712.fall02/papers/p761-thompson.pdf">Ken Thompson’s “Reflections on Trusting Trust”</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-std"><a class="header" href="#why-std">Why std?</a></h1>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>Nix is marvel to ones and cruelty to others.</p>
<p>Much of this professional schism is due to two fundamental issues:</p>
<ul>
<li>Nix is a functional language without typing</li>
<li>Therefore, Nix-enthusiast seem to freaking love writing the most elegant and novel boilerplate all over again the next day.</li>
</ul>
<p>The amount of domain specific knowledge required to untangle those most elegant and novel boilerplate patterns prevent
the other side of the schism, very understandably, to see through the smoke the true beauty and benefits of <code>nix</code> as a
build and configuration language.</p>
<p>Lack of typing adds to the problem by forcing <code>nix</code>-practitioners to go out of their way (e.g. via <a href="https://github.com/divnix/yants"><code>divnix/yants</code></a>) to
add some internal boundaries and contracts to an ever morphing global context.</p>
<p>As a consequence, few actually <em>do</em> that. And contracts across internal code boundaries are either absent or rudimentary or — yet again —
“elegant and novel”. Neither of which satisfactorily settles the issue.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p><code>std</code> doesn’t add language-level typing. But a well-balanced folder layout cut at 3 layers of conceptual
nesting provides the fundamentals for establishing internal boundaries.</p>
<blockquote>
<p><strong>Cell → Cell Block → Target → [Action]</strong></p>
<p>Where …</p>
<ul>
<li><strong>Cells</strong> group functionality.</li>
<li><strong>Cell Blocks</strong> type outputs and implement <strong>Actions</strong>.</li>
<li><strong>Targets</strong> name outputs.</li>
</ul>
</blockquote>
<p>Programmers are really good at pattern-abstraction when looking at two similar but slightly
different things: <em><strong>Cells</strong> and <strong>Cell Blocks</strong> set the stage for code readability.</em></p>
<p><strong>Cell Blocks</strong> only allow one possible interface: <code>{inputs, cell}</code>:</p>
<ul>
<li><code>cell</code> the local <strong>Cell</strong>, promoting separation of concern</li>
<li><code>inputs</code> the <code>deSystemize</code>ed flake inputs — plus:
<ul>
<li><code>inputs.self = self.sourceInfo;</code> reference source code in <code>nix</code>; filter with <code>std.incl</code>; don’t misuse the global <code>self</code>.</li>
<li><code>inputs.cells</code>: the other cells by name; code that documents its boundaries.</li>
<li><code>inputs.nixpkgs</code>: an <em>instantiated</em> <code>nixpkgs</code> for the current system;</li>
</ul>
</li>
</ul>
<p>Now, we have <em>organized</em> <code>nix</code> code. Still, <code>nix</code> is not for everybody.
And for everybody else the <code>std</code> TUI/CLI companion answers a single question to perfection:</p>
<blockquote>
<p><strong>The GitOps Question:</strong></p>
<center><i>What can I actually <b>do</b> with this <code>std</code>-ized repository?</i></center>
&emsp;
</blockquote>
<blockquote>
<p><strong>The Standard Answer:</strong></p>
<center><i><code>std</code> breaks down GitOps into a single UX-optimized TUI/CLI entrypoint.</i></center>
&emsp;
</blockquote>
<h2 id="benefit"><a class="header" href="#benefit">Benefit</a></h2>
<p>Not everybody is going to love <code>nix</code> now.</p>
<p>But the ones, who know its secrets, now have an effective tool
to more empathically spark the joy.</p>
<p>Or simply: 💔 → 🧙 → 🔧 → ✨→ 🏖️</p>
<p>The smallest common denominator, in any case:</p>
<blockquote>
<p>Only ever install a single dependency (<code>nix</code>) and reach <em>any</em> repository target. Reproducibly.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-decision-record"><a class="header" href="#architecture-decision-record">Architecture Decision Record</a></h1>
<p>An architecture decision record (ADR) is a document that captures an
important architectural decision made along with its context and consequences.</p>
<p>The <a href="explain/architecture-decision-records/template.html">template</a> has all the info.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To interact with this ADR, enter the devshell and interact though the <code>adrgen</code> tool.</p>
<hr />
<h1 id="1-adopt-semi-conventional-file-locations"><a class="header" href="#1-adopt-semi-conventional-file-locations">1. Adopt semi-conventional file locations</a></h1>
<p>Date: 2022-03-01</p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>accepted</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Repository navigation is among the first activities to build a mental model of any given repository.
The Nix Ecosystem has come up with some weak conventions: these are variations that are mainly informed by the <code>nixpkgs</code> repository, itself.
Despite that, users find it difficult to quickly &quot;wrap their head&quot; around a new project.
This is often times a result of an organically grown file organization that has trouble keeping up with growing project semantics.
As a result, onboading onto a &quot;new&quot; nix project even within the same organizational context, sometimes can be a very frustrating and time-consuming activity.</p>
<h2 id="decision"><a class="header" href="#decision">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>A semi-conventional folder structure shall be adopted.</p>
<p>That folder structure shall have an abstract organization concept.</p>
<p>At the same time, it shall leave the user maximum freedom of semantics and naming.</p>
<p>Hence, 3 levels of organization are adopted.
These levels correspond to the abstract organizational concepts of:</p>
<ul>
<li>consistent collection of functionality (&quot;what makes sense to group together?&quot;)</li>
<li>repository output type (&quot;what types of gitops artifacts are produced?&quot;)</li>
<li>named outputs (&quot;what are the actual outputs?&quot;)</li>
</ul>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>With this design and despite complete freedom of concrete semantics, a prototypical mental model can be reused across different projects.</p>
<p>That same prototypical mental model also speeds up schaffolding of new content and code.</p>
<p>At the expense of nested folders, it may still be further expanded, if additional organization is required.
All the while that the primary meta-information about a project is properly communicated through these first three levels via the file system api, itself (think <code>ls</code> / <code>rg</code> / <code>fd</code>).</p>
<p>On the other hand, this rigidity is sometimes overkill and users may resort to filler names such as &quot;<code>default</code>&quot;, because a given semantic only produces singletons.
This is acceptable, however, because this parallellity in addressing even these singleton values trades for very easy expansion or refactoring, as the meta-models of code organization already align.</p>
<hr />
<h1 id="2-restrict-the-calling-interface"><a class="header" href="#2-restrict-the-calling-interface">2. Restrict the calling interface</a></h1>
<p>Date: 2022-03-01</p>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<p>accepted</p>
<h2 id="context-1"><a class="header" href="#context-1">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>The Nix Ecosystem has optimized for contributor efficiency at the expense of local code readibility and local reasoning.
Over time, the <code>callPackage</code> idiom was developed that destructures arbitrary attributes of an 80k <em>upstream</em> attributeset provided by <code>nixpkgs</code>.
A complicating side condition is added, where overlays modify that original upstream packages set in arbitrary ways.
This is not a problem for people, who know nixpkgs by heart and it is not a problem for the author either.
It is a problem for the future code reader, Nix expert or less so, who needs to grasp the essence of &quot;what's going on&quot; under a productivity side condidion.</p>
<p>Local reasoning is a tried and tested strategy to help mitigate those issues.</p>
<p>In a variant of this problem, we observe only somewhat convergent, but still largely diverging styles of passing arguments in general across the repository context.</p>
<h2 id="decision-1"><a class="header" href="#decision-1">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Encourage local reasoning by always fully qualifing identifiers within the scope of a single file.</p>
<p>In order to do so, the entry level nix files of this framework have exactly one possible interface: <code>{inputs, cell}</code>.</p>
<p><code>inputs</code> represent the global inputs, whereas <code>cell</code> keeps reference to the local context.
<em>A Cell is the first ordering priciple for &quot;consitent collection of functionality&quot;.</em></p>
<h2 id="consequences-1"><a class="header" href="#consequences-1">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>This restricts up to the prescribed 3 layers of organization the notion of &quot;how files can communicate with each other&quot;.</p>
<p>That inter-files-interface is the <em>only</em> global context to really grasp, and it is structurally aligned across all Standard projects.</p>
<p>By virtue of this meta model of a global context and interfile-communications, for a somewhat familiarized code reader the barriers to local reasoning are greatly reduced.</p>
<p>The two context references are well known (flake inputs &amp; cell-local blocks) and easily discoverable.</p>
<p>For authors, this schema takes away any delay that might arise out of the consideration of how to best structure that inter-file communcation schema.</p>
<p>Out of experience, a significant and low value (and ad-hoc) design process can by leap-frogged via this guidance.</p>
<hr />
<h1 id="3-hide-system-for-mortals"><a class="header" href="#3-hide-system-for-mortals">3. Hide system for mortals</a></h1>
<p>Date: 2022-04-01</p>
<h2 id="status-2"><a class="header" href="#status-2">Status</a></h2>
<p>accepted</p>
<h2 id="context-2"><a class="header" href="#context-2">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>In the context of DevOps (Standard is a DevOps framework), cross compilation is a significatly lesser concern, than what it is for packagers.</p>
<p>The pervasive use of <code>system</code> in the current Nix (and foremost Flakes) Ecosystem is an optimization (and in part education) choice for these packagers.</p>
<p>However, in the context of DevOps, while not being irrelevant, it accounts for a fair share of distraction potential.</p>
<p>This ultimately diminuishes code-readibility and reasoning; and consequentially adoption. Especially in those code paths, where <code>system</code> is a secondary concern.</p>
<h2 id="decision-2"><a class="header" href="#decision-2">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>De-systemize everything to the &quot;current&quot; system and effectively hiding the explict manipulation from plain sight in most cases.</p>
<p>An attribute set, that differentiates for systems on any given level of its tree, is <code>deSystemized</code>.</p>
<p>This means that all child attributes of the &quot;current&quot; system are lifted onto the &quot;system&quot;-level as siblings to the system attributes.</p>
<p>That also means, if explicit reference to <code>system</code> is necessary, it is still there among the siblings.</p>
<p>The &quot;current&quot; system is brought into scope automatically, however.</p>
<p>What &quot;current&quot; means, is an early selector (&quot;select early and forget&quot;), usually determined by the user's operating system.</p>
<h2 id="consequences-2"><a class="header" href="#consequences-2">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>The explicit handling of <code>system</code> in foreing context, where <code>system</code> is not a primary concern is largely eliminated.</p>
<p>This makes using this framework a little easier for everybody, including packaging experts.</p>
<p>Since <code>nixpkgs</code>, itself, exposes <code>nixpkgs.system</code> and packaging without <code>nixpkgs</code> is hardly imaginably, power-users still enjoy easy access to the &quot;current&quot; system, in case it's needed.</p>
<hr />
<h1 id="4-early-select-system-for-conceptual-untangling"><a class="header" href="#4-early-select-system-for-conceptual-untangling">4. Early select system for conceptual untangling</a></h1>
<p>Date: 2022-04-01</p>
<h2 id="status-3"><a class="header" href="#status-3">Status</a></h2>
<p>accepted</p>
<h2 id="context-3"><a class="header" href="#context-3">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Building on the previous ADR, we saw why we hide <code>system</code> from plain sight.</p>
<p>In that ADR, we mention &quot;select early and forget&quot; as a strategy to scope the current system consistently across the project.</p>
<p>The current best practices for flakes postulate <code>system</code> as the second level selector of an output attribute.</p>
<p>For current flakes, type primes over system.</p>
<p>However, this design choice makes the lema &quot;select early and forget&quot; across multiple code-paths a pain to work with.</p>
<p>This handling is exacerbated by the distinction between &quot;systemized&quot; and &quot;non-systemized&quot; (e.g. <code>lib</code>) output attributes.</p>
<p>In the overall set of optimization goals of this framework, this distinction is of extraordinarily poor value, more so, that function
calls are memoized during a single evaluation, which renders the system selector comuptationally irrelevant where not used.</p>
<h2 id="decision-3"><a class="header" href="#decision-3">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<ul>
<li>Move the <code>system</code> selector from the second level to the first level.</li>
<li>Apply the <code>system</code> selector regardless and without excheption.</li>
</ul>
<h2 id="consequences-3"><a class="header" href="#consequences-3">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>The motto &quot;select early and forget&quot; makes various code-paths easier to reason about and maintain.</p>
<p>The Nix CLI completion won't respond gracefully to these changes.
However, the Nix CLI is explicitly <em>not</em> a primary target of this framework.
The reason for this is that the use cases for the Nix CLI are somewhat skewed towards the packager use case, but in any case are (currently) not purpose built for the DevOps use case.</p>
<p>A simple patch to the Nix binary, can mitigate this for people who's muscle memory prefers the Nix CLI regardless.
If you've already got that level of muscle memory, its meandering scope is probably anyways not an issue for you anymore.</p>
<hr />
<h1 id="5-nixpkgs-is-still-special-but-not-too-much"><a class="header" href="#5-nixpkgs-is-still-special-but-not-too-much">5. Nixpkgs is still special, but not too much</a></h1>
<p>Date: 2022-05-01</p>
<h2 id="status-4"><a class="header" href="#status-4">Status</a></h2>
<p>accepted</p>
<h2 id="context-4"><a class="header" href="#context-4">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>In general, Standard wouldn't treat any intput as special.
However, no project that requires source distributions of one of the 80k+ packages available in <code>nixpkgs</code> can practically do without it.</p>
<p>Now, <code>nixpkgs</code> has this wired and counter-intuitive mouthful of <code>legacyPackages</code>, which was originally intended to ring an alarm bell and, for the non-nix-historians, still does.</p>
<p>Also, not very many other package collections adopt this idiom which makes it pretty much a singularity of the Nix package collection (<code>nixpkgs</code>).</p>
<h2 id="decision-4"><a class="header" href="#decision-4">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>If <code>inputs.nixpkgs</code> is provided, in-scope <code>legacyPackages</code> onto <code>inputs.nixpkgs</code>, directly.</p>
<h2 id="consequences-4"><a class="header" href="#consequences-4">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Users of Standard access packages as <code>nixpkgs.&lt;package-name&gt;</code>.</p>
<p>Users that want to interact with nixos, do so by loading <code>nixos = import (inputs.nixpkgs + &quot;/nixos&quot;);</code> or similar.
The close coupling of the Nix Package Collection and NixOS now is broken.
This suites well the DevOps use case, which is not <em>primarily</em> concerned with the unseparable union of the Nix Packages Collection and NixOS.
It rather presents a plethora of use cases that content with the Nix Package Collection, alone, and where NixOS would present as a distraction.
Now, this separation is more <em>explicit</em>.</p>
<p>As another consequence of not treating <code>nixpkgs</code> (or even the packaging use case) special is that Standard does not implement primary support for <code>overlays</code>.</p>
<hr />
<h1 id="6-avoid-fix-point-logic-such-as-overlays"><a class="header" href="#6-avoid-fix-point-logic-such-as-overlays">6. Avoid fix-point logic, such as overlays</a></h1>
<p>Date: 2022-05-01</p>
<h2 id="status-5"><a class="header" href="#status-5">Status</a></h2>
<p>accepted</p>
<h2 id="context-5"><a class="header" href="#context-5">Context</a></h2>
<blockquote>
<p>What is the issue that we're seeing that is motivating this decision or change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Fix point logic is marvelously magic and also very practical.
A lot of people love the concept of <code>nixpkgs</code>'s <code>overlays</code>.</p>
<p>However, we've all been suckers in the early days, and fix point logic wasn't probably one of the concepts that we grasped intuitivly and right at the beginning of our Nix journey.</p>
<p>The concept of recursivity all in itself is already demanding to reason about, where the concept of recourse-until-not-more-possible is even more mind-boggling.</p>
<p>Fix points are also clear instances of overloading global context.</p>
<p>And global context is a double edged sword between high-productivity for that one who has a good mental model of it and nightmare for that one who has to resort to local reasoning.</p>
<h2 id="decision-5"><a class="header" href="#decision-5">Decision</a></h2>
<blockquote>
<p>What is the change that we're proposing and/or doing?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>In the interest of balancing productivity (for the veteran) and ease-of-onboarding (for the novice), we do not implement a prime support for fix-point logic, such as <code>overlays</code> at the framework level.</p>
<h2 id="consequences-5"><a class="header" href="#consequences-5">Consequences</a></h2>
<blockquote>
<p>What becomes easier or more difficult to do because of this change?</p>
</blockquote>
<!-- write an answer to this question below -->
<p>Users who depend on it, need to scope its use to a particular Cell Block.
For the Nix package collection, users can do, for example: <code>nixpkgs.appendOverlays [ /* ... */ ]</code>.
There is a small penalty in evaluating <code>nixpkgs</code> a second time, since every moving of the fix point retriggers a complete evalutation.
But since this decision is made in the interest of <em>balancing</em> enacting trade-offs, this appears to be cost-effective in accordance with the overall optimization goals of Standard.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><em>This is an opinionated pattern.</em></p>
<p><em>It helps structure working together on microservices with <code>std</code>.</em></p>
</blockquote>
<h1 id="the-4-layers-of-packaging"><a class="header" href="#the-4-layers-of-packaging">The 4 Layers of Packaging</a></h1>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>We have written an application and now we want to package and run it.
For its supply chain security benefits, we have been advised to employ reproducible and source-based distribution mechanisms.
We furthermore need an interoperability platform that is generic and versatile: a <em>configuration “lingua franca”</em>.
Our peers who write another application in another language should share that same approach.
Thereby, we avoid the negative external effects of DevOps silos on integrators and operators, alike.
Short: we make adoption of our application as easy as possible for our consumers.</p>
<h2 id="the-actors"><a class="header" href="#the-actors">The Actors</a></h2>
<p><em>Note, that each actor persona can be exercised by one and the same person or a group of persons.
Although possible, and even frequently so, it doesn’t imply that these roles are necessarily taken by distinct individuals.</em></p>
<h3 id="developer"><a class="header" href="#developer">Developer</a></h3>
<p>The Developer persona incrementally modifies the source code.
At times, such modification are relevant at the interface to the Operator persona.
One such example is when the app configuration is modified.
Another one, when important runtime characteristics are amended.</p>
<h3 id="operator"><a class="header" href="#operator">Operator</a></h3>
<p>The Operator persona brings the application to production.
She typically engages in further wrapping code or other artifact creation.
She also supervises and observes the running application across different environments.</p>
<h3 id="release-manager"><a class="header" href="#release-manager">Release Manager</a></h3>
<p>The Release Manager persona cuts releases at discrete points in time.
In doing so, she procures their artifacts for general (public) consumtion.
Any release is tied to a sufficiently high level of assurance of an artifact’s desired properties.
For that purpose, she works with the Developer, Operator &amp; QA personas along these 4 layers of packaging.</p>
<h3 id="qa"><a class="header" href="#qa">QA</a></h3>
<p>The QA persona establishes various levels of assurance of an artifact’s desired properties.
Thereby, the observable artifacts can emanate from any layer of these 4 layers of packaging.
She informs the Developer, Operator and Release Manager personas about any found assurance levels.
She can do so through manual or automatic (CI) means.</p>
<h2 id="the-layers"><a class="header" href="#the-layers">The Layers</a></h2>
<pre class="mermaid">
flowchart TD
    packaging([Packaging])
    operable([Operable])
    image([OCI-Image])
    scheduler([Scheduler Chart])
    packaging --&gt; operable
    operable --&gt; image
    image --&gt; scheduler

    click packaging href &quot;#packaging-layer&quot; &quot;Jump to the packaging layer section&quot;
    click operable href &quot;#operable-layer&quot; &quot;Jump to the operable layer section&quot;
    click image href &quot;#oci-image-layer&quot; &quot;Jump to the OCI image layer section&quot;
    click scheduler href &quot;#scheduler-chart-layer&quot; &quot;Jump to the scheduler chart layer section&quot;
`</pre>
<hr />
<p>There is one very important factoring &amp; interoperability rule about these layers:</p>
<p><em>A domain concern of a higher layer <strong>must not</strong> bleed into previous layers.</em></p>
<p>Observing this very simple rule ensures long term interoperability and maintainability of the stack.
For example, not presuming a particular scheduler in the operable gives contributors a chance to easily add another scheduler target without painful refactoring.</p>
<blockquote>
<p><em><strong>Future Work:</strong> depending on how you count, there may be actually a 5th layer: the <strong>operator</strong> layer. But we may cover this in a future version of this article in further detail. If you don’t want to wait, you may have a conceptual look at the <a href="https://juju.is/docs/olm">Charmed Operator Framework</a> and <a href="https://charmhub.io/">Charmehub</a>.</em></p>
</blockquote>
<p><em>Note, that it would be possible to further fold these interfaces and a Nix veteran might be inclined to do so.
But doing so would defeat the purpose of exposing well defined layered interfaces alongside role-boundaries, subject matter concepts for ease of communication and collaboration; as well as external artifact consumers.</em></p>
<h3 id="packaging-layer"><a class="header" href="#packaging-layer">Packaging Layer</a></h3>
<pre><code class="language-yaml">Cell Block: (blockType.installables &quot;packages&quot;)
Location:  **/packages.nix          # or **/packages/
Actors:
 - Build Expert Panel, Nix- &amp; language-specific
 - Release Manager
</code></pre>
<p>This Cell Block builds, unit-tests &amp; packages the application via the appropriate <a href="patterns/../explain/why-nix.html#nix-superpowers">Nix primitives</a>.
Each programming language has a different best practice approach to packaging.
Therfore, a fair ammount of domain knowledge between Nix and the language’s build system is required.</p>
<p>The location of the actual build instructions are secondary.
At minimum, though, for transparency’s and uniformity’s sake, they are still proxied via this Cell Block.
So in the case that upstream already contains appropriate build instructions, the following indirection is perfectly valid (and necessary):</p>
<pre><code class="language-nix">{ inputs, cell }: {
  app = inputs.upstream.packages.some-app;
}
</code></pre>
<p>Build instructions themselves should encompass executing unit tests.
Builds that fail unit tests should already be filtered out at this layer (i.e. “a build that fails unit tests is no build, at all”).</p>
<p>A Release Manager may decide to provide these artifacts to the general public on tagged releases.</p>
<blockquote>
<p><strong>In a hurry?</strong></p>
<p>Fetching binary artifacts and incorporating them at this layer as a temporary work-around for non-production enviornments is acceptable.</p>
</blockquote>
<h3 id="operable-layer"><a class="header" href="#operable-layer">Operable Layer</a></h3>
<pre><code class="language-yaml">Cell Block: (blockType.runnables &quot;operables&quot;)
Location:  **/operables.nix       # or **/operables/
Actors:
 - Developer
 - Operator
</code></pre>
<p>This Cell Block exclusively defines the runtime environment of the application via the operable script.
The role of this script — customarily written in <code>bash</code> — serves as a concise and reified communication channel between Developers and Operators.
As such, Operators will find all the primary configuration options re-encoded at a glance and in a well-known location.
In the other direction, Developers will find all the magic ad-hoc wrapping that Operators had to engage in, in order to run the application on the target scheduler.</p>
<p>Through this communication channel, operators take reliably note of configuration drift, while Developers gain a valuable source of backlog to increase the operational robustness of the application.</p>
<p>Standard includes a <a href="patterns/../reference/lib/ops/mkOperable.html">specific library function</a> that establishes an implementation-site interface for operables and their collaterals which significantly eases working on the following layers.</p>
<h3 id="oci-image-layer"><a class="header" href="#oci-image-layer">OCI-Image Layer</a></h3>
<pre><code class="language-yaml">Cell Block: (blockType.containers &quot;oci-images&quot;)
Location:  **/oci-images.nix        # or **/oci-images/
Actors:
 - Operator
 - Release Manager
</code></pre>
<p>This layered packaging pattern promotes source-based distribution in principle.
Despite, in common operating scenarios, we require a security stop-gap separation.
This ensures very fundamentally that nothing is accidentially <em>built</em> on the target (production) worker node, where it would cannibalize critical resources.</p>
<p>We chose OCI-Images as the binary distribution format.
It not only fits that purpose through the <a href="https://github.com/opencontainers/distribution-spec">OCI Distribution Specification</a>, but also collaterally procures interoperability for 3rd parties:
OCI images are the de-facto industry standard for deployment artifacts.</p>
<p>If the operables have been created via the above mentioned <a href="patterns/../reference/lib/ops/mkOperable.html">library function</a>.
Using the <a href="patterns/../reference/lib/ops/mkStandardOCI.html">Standard OCI image library function</a>, the creation of OCI images trivially reduces to:</p>
<pre><code class="language-nix">{ inputs, cell }: let
  inherit (inputs.std.lib) ops;
in {
  image-hard = ops.mkStandardOCI {
    name = &quot;docker.io/my-image-hardened&quot;;
    operable = cell.operables.app;
  };
  image = ops.mkStandardOCI {
    name = &quot;docker.io/my-image&quot;;
    operable = cell.operables.app;
    debug = true;
  };
}
</code></pre>
<p>Alternatively, any of the avaible Nix-based OCI generation mini-frameworks can be used;
<a href="https://github.com/nlewo/nix2container"><code>nlewo/nix2container</code></a> being the recommended one.
Hence, this mini-framework is internally used by the operables library function.</p>
<p>A Release Manager may decide to provide these artifacts to the general public on tagged releases.</p>
<blockquote>
<p><strong>In a hurry?</strong></p>
<p>Fetching published images and incorporating them at this layer as a temporary work-around for non-production enviornments is acceptable.</p>
</blockquote>
<h3 id="scheduler-chart-layer"><a class="header" href="#scheduler-chart-layer">Scheduler Chart Layer</a></h3>
<pre><code class="language-yaml">Cell Block: (blockType.functions &quot;&lt;sched&gt;Charts&quot;)
Location:  **/&lt;sched&gt;Charts.nix     # or **/&lt;sched&gt;Charts/
Actors:
 - Operator
 - Release Manager
</code></pre>
<p>The scheduler chart is not <em>yet</em> mainfest data.
Rather, it is a function interface that commonly renders to such json-serializable manifest data.
These mainfests are then ingested and interpreted by the scheduler.</p>
<p>A fair amount of scheduler domain knowledge and familiarity with its scheduling options is required, especially
during creation.</p>
<p>These charts can then be processed further downstream (e.g. in Nix code) to specialize out the final manifests and environments.</p>
<p>Since these charts are the basis of various environments for development, staging and production, it is <em>highly</em> recommended to keep their function interface extremely mininmal <strong>and</strong> stable.
This avoids the risk of inadvertely modifying production manifests (e.g. via a human error in the base charts) based on a development or staging requirement.
In these cases, it is <em>highly</em> recommended to resort to data-oriented overlay mechanisms for ad-hoc modification.
A purpose-built tool to do so (called <a href="https://github.com/divnix/data-merge"><code>data-merge</code></a>) is already re-exported under <code>std.dmerge</code> for convenience.
Those modifications should only propagate into a chart interface after <em>stabilizing</em> and after having successfully percolated through all existing environments first.</p>
<p>A Release Manager may decide to provide these artifacts to the general public on tagged releases.
For example: in the transpiled form of a widely used scheduler-specific config sharing format, such as <a href="https://helm.sh/docs/topics/charts/">helm-charts</a>.</p>
<blockquote>
<p><em><strong>Future Work:</strong> it might be a feasible task to extract a common base interface among different schedulers
and thereby implement a base chart that we could simply specialize for each target schedulers (including <code>systemd</code>).
But this may be subject of future research.
Potentially, the above mentioned <a href="https://juju.is/docs/olm">Charmed Operator Framework</a> even obsoletes that need a priori and in practical terms.</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-and-nix-and-rust-oh-my"><a class="header" href="#standard-and-nix-and-rust-oh-my">Standard, and Nix and Rust, oh my!</a></h1>
<p>This template uses <a href="https://nixos.org">Nix</a> to create a sane development shell for
Rust projects, <a href="https://github.com/divnix/std#readme">Standard</a> for keeping your Nix code well organized,
<a href="https://github.com/nix-community/fenix#readme">Fenix</a> for pulling the latest rust binaries via Nix, and
<a href="https://github.com/ipetkov/crane#readme">Crane</a> for building Rust projects in Nix incrementally, making
quick iteration a breeze.</p>
<p>Rust Analyzer is also wired up properly for immediate use from a
terminal based editor with language server support. Need one with
stellar Nix and Rust support? Try <a href="https://github.com/helix-editor/helix#readme">Helix</a>!</p>
<h2 id="bootstrap"><a class="header" href="#bootstrap">Bootstrap</a></h2>
<pre><code class="language-bash"># make a new empty project dir
mkdir my-project
cd my-project

# grab the template
nix flake init -t github:divnix/std#rust

# do some inititialization
git init
cargo init # pass --lib for library projects
cargo build # to generate Cargo.lock
git add .
g commit -m &quot;init&quot;

# enter the devshell
direnv allow || nix develop
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuicli"><a class="header" href="#tuicli">TUI/CLI</a></h1>
<h4 id="tuicli-1"><a class="header" href="#tuicli-1">TUI/CLI:</a></h4>
<pre><code class="language-console"># TUI
std

# CLI
std //&lt;TAB&gt;
std re-cache # refresh the CLI cache
std list     # show a list of all targets

# Version
std -v
</code></pre>
<h4 id="help"><a class="header" href="#help">Help:</a></h4>
<pre><code class="language-console">❯ std -h
std is the CLI / TUI companion for Standard.

- Invoke without any arguments to start the TUI.
- Invoke with a target spec and action to run a known target's action directly.

Usage:
  std //[cell]/[block]/[target]:[action] [args...]
  std [command]

Available Commands:
  list        List available targets.
  re-cache    Refresh the CLI cache.

Flags:
  -h, --help      help for std
  -v, --version   version for std

Use &quot;std [command] --help&quot; for more information about a command.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conventions-in-std"><a class="header" href="#conventions-in-std">Conventions in <code>std</code></a></h1>
<p>In principle, we all want to be able to read code with local reasoning.</p>
<p>However, these few conventions are pure quality of life and
help us to keep our nix code organized.</p>
<h2 id="nix-file-locations"><a class="header" href="#nix-file-locations">Nix File Locations</a></h2>
<p>Nix files are imported from either of these two locations, if present, in this order of precedence:</p>
<pre><code>${cellsFrom}/${cell}/${block}.nix
${cellsFrom}/${cell}/${block}/default.nix
</code></pre>
<h2 id="readme-file-locations"><a class="header" href="#readme-file-locations">Readme File Locations</a></h2>
<p>Readme files are picked up by the TUI in the following places:</p>
<pre><code>${cellsFrom}/${cell}/Readme.md
${cellsFrom}/${cell}/${block}/Readme.md
${cellsFrom}/${cell}/${block}/${target}.md
</code></pre>
<h2 id="cell-block-file-arguments"><a class="header" href="#cell-block-file-arguments">Cell Block File Arguments</a></h2>
<p>Each Cell Block is a function and expects the following standardized interface for interoperability:</p>
<pre><code class="language-nix">{ inputs, cell }: {}
</code></pre>
<h2 id="the-inputs-argument"><a class="header" href="#the-inputs-argument">The <code>inputs</code> argument</a></h2>
<p>The <code>inputs</code> argument holds all the de-systemized flake inputs plus a few special inputs:</p>
<pre><code class="language-nix">{
  inputs = {
    self = {}; # sourceInfo of the current repository
    nixpkgs = {}; # an _instantiated_ nixpkgs
    cells = {}; # the other cells in this repo
  };
}
</code></pre>
<h2 id="the-cell-argument"><a class="header" href="#the-cell-argument">The <code>cell</code> argument</a></h2>
<p>The <code>cell</code> argument holds all the different Cell Block targets of the current cell.
This is the main mechanism by which code organization and separation of concern is enabled.</p>
<h2 id="the-desytemized-inputs"><a class="header" href="#the-desytemized-inputs">The <code>deSytemize</code>d inputs</a></h2>
<p>All inputs are scoped for the <em>current</em> system, that is derived from the <code>systems</code> input list to <code>std.grow</code>.
That means contrary to the usual nix-UX, in most cases, you don’t need to worry about <code>system</code>.</p>
<p>The current system will be “lifted up” one level, while still providing full access to all <code>systems</code> for
cross-compilation scenarios.</p>
<pre><code class="language-nix"># inputs.a.packages.${system}
{
  inputs.a.packages.pkg1 = {};
  inputs.a.packages.pkg2 = {};
  /* ... */
  inputs.a.packages.${system}.pkgs1 = {};
  inputs.a.packages.${system}.pkgs2 = {};
  /* ... */
}
</code></pre>
<h4 id="desystemizes-implementation"><a class="header" href="#desystemizes-implementation"><code>deSystemize</code>’s implementation</a></h4>
<pre><code class="language-nix">let
  l = builtins;
  /*
  A helper function which hides the complexities of dealing
  with 'system' properly from you, while still providing
  escape hatches when dealing with cross-compilation.

  You can use this function independently of the rest of std.
  */
  deSystemize = let
    iteration = cutoff: system: fragment:
      if ! (l.isAttrs fragment) || cutoff == 0
      then fragment
      else if l.hasAttr &quot;${system}&quot; fragment &amp;&amp; ! l.isFunction fragment.${system}
      then fragment // fragment.${system}
      else if l.hasAttr &quot;${system}&quot; fragment &amp;&amp; l.isFunction fragment.${system}
      then fragment // {__functor = _: fragment.${system};}
      else l.mapAttrs (_: iteration (cutoff - 1) system) fragment;
  in
    iteration 3;
in
  deSystemize
</code></pre>
<h2 id="top-level-system-scoping-of-outputs"><a class="header" href="#top-level-system-scoping-of-outputs">Top-level <code>system</code>-scoping of outputs</a></h2>
<p>Contrary to the upstream flake schema, all outputs are <code>system</code> spaced at the top-level.
This allows us to uniformly select on the <em>current</em> system and forget about it for most
of the time.</p>
<p>Sometimes <code>nix</code> evaluations don’t strictly depend on a particular <code>system</code>, and scoping
them seems counter-intuitive. But due to the fact that function calls are memoized, there
is never a penalty in actually scoping them. So for the sake of uniformity, we scope them
anyways.</p>
<p>The outputs therefore abide by the following “schema”:</p>
<pre><code class="language-nix">{
  ${system}.${cell}.${block}.${target} = {};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deprecations"><a class="header" href="#deprecations">Deprecations</a></h1>
<pre><code class="language-nix">{inputs}: time: body: let
  l = inputs.nixpkgs.lib // builtins;
  pad = l.concatStringsSep &quot;&quot; (l.genList (_: &quot; &quot;) (21 - (l.stringLength time)));
in
  l.warn ''


    ===============================================
    !!!  🔥️  STANDARD DEPRECATION WARNING  🔥️   !!!
    -----------------------------------------------
    !!! Action required until scheduled removal !!!
    !!! Sheduled Removal: ${pad}${time} !!!
    -----------------------------------------------
    On schedule, deprecated facilities will be
    removed from Standard without further warning.
    -----------------------------------------------
    ${body}
    ===============================================

    ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳



  ''
</code></pre>
<p>Please observe the following deprecations and their deprecation schedule:</p>
<pre><code class="language-nix">inputs: let
  removeBy = import ./cells/std/errors/removeBy.nix {inherit inputs;};
in {
  warnClade = variant:
    removeBy &quot;October 2022&quot; ''

      &quot;clade&quot; nomenclature is deprecated.

      Please rename:

      - sed -i 's/clades/blockTypes/g'
      - sed -i 's/clade/blockType/g'
      - sed -i 's/Clades/Block Types/g'
      - sed -i 's/Clade/Block Type/g'

      There is an old revision of `std` in the evaluation path,
      possibly in one of your flake inputs.

      Detected in: ${variant}

      Please review your code base and/or inform upstream to
      update their version of Standard ASAP.

      see: https://github.com/divnix/std/issues/116
    '';

  warnOrganelles = project:
    removeBy &quot;October 2022&quot; ''

      &quot;organelle&quot; nomenclature is deprecated.

      Please rename:

      - sed -i 's/organelles/cellBlocks/g'
      - sed -i 's/organelle/cellBlock/g'
      - sed -i 's/Organelles/Cell Blocks/g'
      - sed -i 's/Organelle/Cell Block/g'

      There is an old revision of `std` in the evaluation path
      in project: ${toString project}

      Please review your code base and/or inform upstream to
      update their version of Standard ASAP.

      see: https://github.com/divnix/std/issues/116
    '';

  warnRemovedDevshellOptionAdr = removeBy &quot;December 2022&quot; ''
    The std.adr.enable option has been removed from the std shell.
    Please look for something like &quot;adr.enable = false&quot; and drop it.
  '';
  warnRemovedDevshellOptionDocs = removeBy &quot;December 2022&quot; ''
    The std.docs.enable option has been removed from the std shell.
    Please look for something like &quot;docs.enable = false&quot; and drop it.
  '';
  warnMkMakes = removeBy &quot;December 2022&quot; ''
    std.lib.fromMakesWith has been refactored to std.lib.mkMakes.

    It furthermore doesn't take 'inputs' as its first argument
    anymore.
  '';
  warnMkMicrovm = removeBy &quot;December 2022&quot; ''
    std.lib.fromMicrovmWith has been refactored to std.lib.mkMicrovm.

    It furthermore doesn't take 'inputs' as its first argument
    anymore.
  '';

  warnNewLibCell = removeBy &quot;December 2022&quot; ''

    'std.std.lib' has been distributed into its own cell 'std.lib'

    Please access functions via their new location:

    ... moved to 'std.lib.ops':
    - 'std.std.lib.mkMicrovm' -&gt; 'std.lib.ops.mkMicrovm'
    - 'std.std.lib.writeShellEntrypoint' -&gt; 'std.lib.ops.writeShellEntrypoint'

    ... moved to 'std.lib.dev':
    - 'std.std.lib.mkShell' -&gt; 'std.lib.dev.mkShell'
    - 'std.std.lib.mkNixago' -&gt; 'std.lib.dev.mkNixago'
    - 'std.std.lib.mkMakes' -&gt; 'std.lib.dev.mkMakes'
  '';

  warnWriteShellEntrypoint = removeBy &quot;December 2022&quot; ''

    'std.lib.ops.writeShellEntrypoint' is deprecated.

    Instead, use 'std.lib.ops.mkOperable' together
    with 'std.lib.ops.mkStandardOCI'.

    Please consult its documentation.
  '';
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin-block-types"><a class="header" href="#builtin-block-types">Builtin Block Types</a></h1>
<p>A few Block Types are packaged with <code>std</code>.</p>
<p>In practical terms, Block Types distinguish themselves through the
actions they provide to a particular Cell Block.</p>
<p>It is entirely possible to define custom Block Types with custom
Actions according to the needs of your project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data"><a class="header" href="#data">Data</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Data Blocktype for json serializable data.

  Available actions:
    - write
    - explore

  For all actions is true:
    Nix-proper 'stringContext'-carried dependency will be realized
    to the store, if present.
  */
  data = name: {
    inherit name;
    type = &quot;data&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: let
      builder = [&quot;nix&quot; &quot;build&quot; &quot;--impure&quot; &quot;--json&quot; &quot;--no-link&quot; &quot;--expr&quot; expr];
      jq = [&quot;|&quot; &quot;${nixpkgs.legacyPackages.${system}.jq}/bin/jq&quot; &quot;-r&quot; &quot;'.[].outputs.out'&quot;];
      fx = [&quot;|&quot; &quot;xargs&quot; &quot;cat&quot; &quot;|&quot; &quot;${nixpkgs.legacyPackages.${system}.fx}/bin/fx&quot;];
      expr = l.strings.escapeShellArg ''
        let
          pkgs = (builtins.getFlake &quot;${nixpkgs.sourceInfo.outPath}&quot;).legacyPackages.${system};
          this = (builtins.getFlake &quot;${flake}&quot;).${fragment};
        in
          pkgs.writeTextFile {
            name = &quot;data.json&quot;;
            text = builtins.toJSON this;
          }
      '';
    in [
      {
        name = &quot;write&quot;;
        description = &quot;write to file&quot;;
        command = l.concatStringsSep &quot;\t&quot; (builder ++ jq);
      }
      {
        name = &quot;explore&quot;;
        description = &quot;interactively explore&quot;;
        command = l.concatStringsSep &quot;\t&quot; (builder ++ jq ++ fx);
      }
    ];
  };
in
  data
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Functions Blocktype for reusable nix functions that you would
  call elswhere in the code.

  Also use this for all types of modules and profiles, since they are
  implemented as functions.

  Consequently, there are no actions available for functions.
  */
  functions = name: {
    inherit name;
    type = &quot;functions&quot;;
  };
in
  functions
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runnables"><a class="header" href="#runnables">Runnables</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Runnables Blocktype for targets that you want to
  make accessible with a 'run' action on the TUI.
  */
  runnables = name: {
    inherit name;
    type = &quot;runnables&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;run&quot;;
        description = &quot;exec this target&quot;;
        command = ''
          nix run ${flake}#${fragment} -- &quot;$@&quot;
        '';
      }
    ];
  };
in
  runnables
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installables"><a class="header" href="#installables">Installables</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Installables Blocktype for targets that you want to
  make availabe for installation into the user's nix profile.

  Available actions:
    - install
    - upgrade
    - remove
    - build
    - bundle
    - bundleImage
    - bundleAppImage
  */
  installables = name: {
    inherit name;
    type = &quot;installables&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;install&quot;;
        description = &quot;install this target&quot;;
        command = ''
          nix profile install ${flake}#${fragment}
        '';
      }
      {
        name = &quot;upgrade&quot;;
        description = &quot;upgrade this target&quot;;
        command = ''
          nix profile upgrade ${flake}#${fragment}
        '';
      }
      {
        name = &quot;remove&quot;;
        description = &quot;remove this target&quot;;
        command = ''
          nix profile remove ${flake}#${fragment}
        '';
      }
      {
        name = &quot;build&quot;;
        description = &quot;build this target&quot;;
        command = ''
          nix build ${flake}#${fragment}
        '';
      }
      {
        name = &quot;bundle&quot;;
        description = &quot;bundle this target&quot;;
        command = ''
          nix bundle --bundler github:Ninlives/relocatable.nix --refresh ${flake}#${fragment}
        '';
      }
      {
        name = &quot;bundleImage&quot;;
        description = &quot;bundle this target to image&quot;;
        command = ''
          nix bundle --bundler github:NixOS/bundlers#toDockerImage --refresh ${flake}#${fragment}
        '';
      }
      {
        name = &quot;bundleAppImage&quot;;
        description = &quot;bundle this target to AppImage&quot;;
        command = ''
          nix bundle --bundler github:ralismark/nix-appimage --refresh ${flake}#${fragment}
        '';
      }
    ];
  };
in
  installables
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microvms"><a class="header" href="#microvms">Microvms</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Microvms Blocktype for Microvm.nix - https://github.com/astro/microvm.nix

  Available actions:
    - microvm
  */
  substituters = &quot;--option extra-substituters https://microvm.cachix.org&quot;;
  keys = &quot;--option extra-trusted-public-keys microvm.cachix.org-1:oXnBc6hRE3eX5rSYdRyMYXnfzcCxC7yKPTbZXALsqys=&quot;;

  microvms = name: {
    inherit name;
    type = &quot;microvms&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: let
      run = [&quot;nix&quot; &quot;run&quot; &quot;${flake}#${fragment}.config.microvm.runner&quot;];
    in [
      {
        name = &quot;microvm&quot;;
        description = &quot;exec this microvm&quot;;
        command =
          (l.concatStringsSep &quot;\t&quot; run)
          + &quot;.$(nix eval --json --option warn-dirty false\ &quot;
          + &quot;${flake}#${fragment}.config.microvm.hypervisor)&quot;
          + &quot;\ ${substituters} ${keys}&quot;;
      }
    ];
  };
in
  microvms
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devshells"><a class="header" href="#devshells">Devshells</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Devshells Blocktype for devShells.

  Available actions:
    - enter
  */
  devshells = name: {
    inherit name;
    type = &quot;devshells&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;enter&quot;;
        description = &quot;enter this devshell&quot;;
        command = ''
          std_layout_dir=$PRJ_ROOT/.std
          profile_path=&quot;$std_layout_dir/${fragmentRelPath}&quot;
          mkdir -p &quot;$profile_path&quot;
          nix_args=(
            &quot;$PRJ_ROOT#${fragment}&quot;
            &quot;--no-update-lock-file&quot;
            &quot;--no-write-lock-file&quot;
            &quot;--no-warn-dirty&quot;
            &quot;--accept-flake-config&quot;
            &quot;--no-link&quot;
            &quot;--build-poll-interval&quot; &quot;0&quot;
            &quot;--builders-use-substitutes&quot;
          )
          nix build &quot;''${nix_args[@]}&quot; --profile &quot;$profile_path/shell-profile&quot;
          bash -c &quot;source $profile_path/shell-profile/env.bash; SHLVL=$SHLVL; __devshell-motd; exec $SHELL -i&quot;
        '';
      }
    ];
  };
in
  devshells
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containers"><a class="header" href="#containers">Containers</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Containers Blocktype for OCI-images built with nix2container.

  Available actions:
    - print-image
    - copy-to-registry
    - copy-to-podman
    - copy-to-docker
  */
  containers = name: {
    inherit name;
    type = &quot;containers&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;print-image&quot;;
        description = &quot;print out the image name &amp; tag&quot;;
        command = ''
          echo
          echo &quot;$(nix eval --raw ${flake}#${fragment}.imageName):$(nix eval --raw ${flake}#${fragment}.imageTag)&quot;
        '';
      }
      {
        name = &quot;copy-to-registry&quot;;
        description = &quot;copy the image to its remote registry&quot;;
        command = ''
          nix run ${flake}#${fragment}.copyToRegistry
        '';
      }
      {
        name = &quot;copy-to-docker&quot;;
        description = &quot;copy the image to the local docker registry&quot;;
        command = ''
          nix run ${flake}#${fragment}.copyToDockerDaemon
        '';
      }
      {
        name = &quot;copy-to-podman&quot;;
        description = &quot;copy the image to the local podman registry&quot;;
        command = ''
          nix run ${flake}#${fragment}.copyToPodman
        '';
      }
    ];
  };
in
  containers
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nixago"><a class="header" href="#nixago">Nixago</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the Nixago Blocktype for nixago pebbles.

  Use Nixago pebbles to ensure files are present
  or symlinked into your repository. You may typically
  use this for repo dotfiles.

  For more information, see: https://github.com/nix-community/nixago.

  Available actions:
    - ensure
    - explore

  */
  nixago = name: {
    inherit name;
    type = &quot;nixago&quot;;
    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: [
      {
        name = &quot;populate&quot;;
        description = &quot;populate this nixago file into the repo&quot;;
        command = ''
          nix run ${flake}#${fragment}.install
        '';
      }
      {
        name = &quot;explore&quot;;
        description = &quot;interactively explore the nixago file&quot;;
        command = ''
          ${nixpkgs.legacyPackages.${system}.bat}/bin/bat &quot;$(nix build --no-link --print-out-paths ${flake}#${fragment}.configFile)&quot;
        '';
      }
    ];
  };
in
  nixago
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nomad-job-manfiests"><a class="header" href="#nomad-job-manfiests">Nomad Job Manfiests</a></h1>
<pre><code class="language-nix">{nixpkgs}: let
  l = nixpkgs.lib // builtins;
  /*
  Use the `nomadJobsManifest` Blocktype for rendering job descriptions
  for the Nomad Cluster scheduler. Each named attribtute-set under the
  block contains a valid Nomad job description, written in Nix.

  Available actions:
    - render
    - deploy
    - explore
  */
  nomadJobManifests = name: {
    inherit name;
    type = &quot;nomadJobManifests&quot;;

    actions = {
      system,
      flake,
      fragment,
      fragmentRelPath,
    }: let
      fx = &quot;${nixpkgs.legacyPackages.${system}.fx}/bin&quot;;
      nomad = &quot;${nixpkgs.legacyPackages.${system}.nomad}/bin&quot;;
      jq = &quot;${nixpkgs.legacyPackages.${system}.jq}/bin&quot;;
      nixExpr = ''
        x: let
          job = builtins.mapAttrs (_: v: v // {meta = v.meta or {} // {rev = &quot;\&quot;$(git rev-parse --short HEAD)\&quot;&quot;;};}) x.job;
        in
          builtins.toFile \&quot;$job.json\&quot; (builtins.unsafeDiscardStringContext (builtins.toJSON {inherit job;}))
      '';
      layout = ''
        std_layout_dir=$PRJ_ROOT/.std
        job_path=&quot;$std_layout_dir/${dirOf fragmentRelPath}/${baseNameOf fragmentRelPath}.json&quot;

        # use Nomad bin in path if it exists, and only fallback on nixpkgs if it doesn't
        PATH=&quot;$PATH:${nomad}&quot;
      '';
      render = ''
        echo &quot;Rendering to $job_path...&quot;

        # use `.` instead of ${flake} to capture dirty state
        if ! out=&quot;$(nix eval --no-allow-dirty --raw .\#${fragment} --apply &quot;${nixExpr}&quot;)&quot;; then
          &gt;&amp;2 echo &quot;error: Will not render jobs from a dirty tree, otherwise we cannot keep good track of deployment history.&quot;
          exit 1
        fi

        nix build &quot;$out&quot; --out-link &quot;$job_path&quot; 2&gt;/dev/null

        if status=$(nomad validate &quot;$job_path&quot;); then
          echo &quot;$status for $job_path&quot;
        fi
      '';
    in [
      /*
      The `render` action will take this Nix job descrition, convert it to JSON,
      inject the git revision validate the manifest, after which it can be run or
      planned with the Nomad cli or the `deploy` action.
      */
      {
        name = &quot;render&quot;;
        description = &quot;build the JSON job description&quot;;
        command =
          # bash
          ''
            set -e

            ${layout}

            ${render}
          '';
      }
      {
        name = &quot;deploy&quot;;
        description = &quot;Deploy the job to Nomad&quot;;
        command =
          # bash
          ''
            set -e

            ${layout}

            PATH=$PATH:${jq}

            if ! [[ -h &quot;$job_path&quot; ]] \
              || [[ &quot;$(jq -r '.job[].meta.rev' &quot;$job_path&quot;)&quot; != &quot;$(git rev-parse --short HEAD)&quot; ]]
            then ${render}
            fi

            if ! plan_results=$(nomad plan -force-color &quot;$job_path&quot;); then
              echo &quot;$plan_results&quot;

              cmd=&quot;$(echo &quot;$plan_results&quot; | grep 'nomad job run -check-index')&quot;

              # prompt user interactiely except in CI
              if ! [[ -v CI ]]; then
                read -rp &quot;Deploy this job? (y/N)&quot; deploy

                case &quot;$deploy&quot; in
                [Yy])
                  eval &quot;$cmd&quot;
                  ;;
                *)
                  echo &quot;Exiting without deploying&quot;
                  ;;
                esac
              else
                eval &quot;$cmd&quot;
              fi
            else
              echo &quot;Job hasn't changed since last deployment, nothing to deploy&quot;
            fi
          '';
      }
      {
        name = &quot;explore&quot;;
        description = &quot;interactively explore the Job defintion&quot;;
        command =
          # bash
          ''
            set -e

            ${layout}

            if ! [[ -h &quot;$job_path&quot; ]]; then
            ${render}
            fi

            PATH=$PATH:${fx}

            fx &quot;$job_path&quot;
          '';
      }
    ];
  };
in
  nomadJobManifests
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-cell"><a class="header" href="#the-std-cell">The <code>std</code> Cell</a></h1>
<p>… is the only cell in <code>divnix/std</code> and provides only very limited functionality.</p>
<ul>
<li>It contains the TUI, in <code>./cli</code>.</li>
<li>It contains a <code>devshellProfile</code> in <code>./devshellProfiles</code>.</li>
<li>It contains a growing number of second level library functions in <code>./lib</code>.</li>
<li>Packages that are used in std devshells are proxied in <code>./packages</code>.</li>
</ul>
<p>That’s it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-tui--cli"><a class="header" href="#the-std-tui--cli">The <code>std</code> TUI / CLI</a></h1>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<ul>
<li>Enter a <code>std</code>ized repository.</li>
<li>Enter it’s devshell (which must include <code>//std/devshellProfiles:default</code>)</li>
<li>Run <code>std</code>.</li>
</ul>
<p>It will show you around interactively and lead you very quickly to what you’re looking for.</p>
<p>It’s self-documented on it’s legend.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stds-devshellprofiles"><a class="header" href="#stds-devshellprofiles"><code>std</code>’s <code>devshellProfiles</code></a></h1>
<p>This Cell Block only exports a single <code>default</code> devshellProfile.</p>
<p>Any <code>std</code>ized repository should include this into its <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code></a>
in order to provide any visitor with the fully pre-configured <code>std</code> TUI.</p>
<p>It also wires &amp; instantiates a decent ADR tool. Or were you planning to hack away
without some minimal conscious effort of decision making and recording? 😅</p>
<h1 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h1>
<pre><code class="language-nix"># ./nix/_automation/devshells.nix
{
  inputs,
  cell,
}: let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
  inherit (inputs.std) std;
in
  l.mapAttrs (_: std.lib.mkShell) {
    # `default` is a special target in newer nix versions
    # see: harvesting below
    default = {
      name = &quot;My Devshell&quot;;
      # make `std` available in the numtide/devshell
      imports = [ std.devshellProfiles.default ];
    };
  }
</code></pre>
<pre><code class="language-nix"># ./flake.nix
{
  inputs.std.url = &quot;github:divnix/std&quot;;

  outputs = inputs:
    inputs.std.growOn {
      inherit inputs;
      cellsFrom = ./nix;
      cellBlocks = [
        /* ... */
        (inputs.std.blockTypes.devshells &quot;devshells&quot;)
      ];
    }
    # soil for compatiblity ...
    {
      # ... with `nix develop` - `default` is a special target for `nix develop`
      devShells = inputs.std.harvest inputs.self [&quot;automation&quot; &quot;devshells&quot;];
    };
}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-std-nixago-pebbles"><a class="header" href="#the-std-nixago-pebbles">The <code>std</code> Nixago Pebbles</a></h1>
<p>Standard comes packages with some <a href="https://github.com/nix-community/nixago">Nixago</a> Pebbles for easy
downstream re-use.</p>
<p>Some Pebbles may have a special integration for <code>std</code>.</p>
<p>For example, the <code>conform</code> Pebble can undestand <code>inputs.cells</code>
and add each Cell as a so called “scope” to its
<a href="https://www.conventionalcommits.org/">Conventional Commit</a> configuration.</p>
<hr />
<p>If you’re rather looking for Nixago Presets (i.e. pebbles that already have an opinionated default), please refer to the <a href="reference/std/nixago/../../../reference/presets/nixago"><em>nixago presets</em></a>, instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adrgen"><a class="header" href="#adrgen"><a href="https://github.com/asiermarques/adrgen"><code>adrgen</code></a></a></h1>
<p>A great tool to manage Architecture Decision Records.</p>
<hr />
<h4 id="definition"><a class="header" href="#definition">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
in {
  configData = {};
  output = &quot;adrgen.config.yml&quot;;
  format = &quot;yaml&quot;;
  commands = [{package = cell.packages.adrgen;}];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conform"><a class="header" href="#conform"><a href="https://github.com/siderolabs/conform"><code>conform</code></a></a></h1>
<p>Conform your code to policies, e.g. in a pre-commit hook.</p>
<p>This version is wrapped, it can auto-enhance the conventional
commit scopes with your <code>cells</code> as follows:</p>
<pre><code class="language-nix">{ inputs, cell}: let
  inherit (inputs.std) std;
in {

  default = std.lib.mkShell {
    /* ... */
    nixago = [
      (std.nixago.conform {configData = {inherit (inputs) cells;};})
    ];
  };
}
</code></pre>
<hr />
<h4 id="definition-1"><a class="header" href="#definition-1">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  l = nixpkgs.lib // builtins;
  inherit (inputs) nixpkgs;
in {
  configData = {};
  format = &quot;yaml&quot;;
  output = &quot;.conform.yaml&quot;;
  packages = [nixpkgs.conform];
  apply = d: {
    policies =
      []
      ++ (l.optional (d ? commit) {
        type = &quot;commit&quot;;
        spec =
          d.commit
          // l.optionalAttrs (d ? cells) {
            conventional =
              d.commit.conventional
              // {
                scopes =
                  d.commit.conventional.scopes
                  ++ (l.subtractLists l.systems.doubles.all (l.attrNames d.cells));
              };
          };
      })
      ++ (l.optional (d ? license) {
        type = &quot;license&quot;;
        spec = d.license;
      });
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editorconfig"><a class="header" href="#editorconfig"><a href="https://github.com/editorconfig/"><code>editorconfig</code></a></a></h1>
<p>Most editors understand this file and autoconfigure themselves accordingly.</p>
<hr />
<h4 id="definition-2"><a class="header" href="#definition-2">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
in {
  configData = {};
  output = &quot;.editorconfig&quot;;
  format = &quot;ini&quot;;
  packages = [nixpkgs.editorconfig-checker];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="just"><a class="header" href="#just"><a href="https://github.com/casey/just"><code>just</code></a></a></h1>
<p>Just is a general purpose command runner with syntax inspired by <code>make</code>.</p>
<p>Tasks are configured via an attribute set where the name is the name of the task
(i.e. <code>just &lt;task&gt;</code>) and the value is the task definition (see below for an
example). The generated <code>Justfile</code> should be committed to allow non-Nix users to
on-ramp without needing access to Nix.</p>
<p>Task dependencies (i.e. <code>treefmt</code> below) should be included in <code>packages</code> and
will automatically be picked up in the devshell.</p>
<pre><code class="language-nix">{ inputs, cell }:
let
  inherit (inputs.std) nixpkgs std;
in
{

  default = std.lib.mkShell {
    /* ... */
    nixago = [
      (std.nixago.just {
        packages = [ nixpkgs.treefmt ];
        configData = {
          tasks = {
            fmt = {
              description = &quot;Formats all changed source files&quot;;
              content = ''
                treefmt $(git diff --name-only --cached)
              '';
            };
          };
        };
      })
    ];
  };
}
</code></pre>
<p>It’s also possible to override the interpreter for a task:</p>
<pre><code class="language-nix">{
# ...
  hello = {
    description = &quot;Prints hello world&quot;;
    interpreter = nixpkgs.python3;
    content = ''
      print(&quot;Hello, world!&quot;)
    '';
  };
}
# ...
</code></pre>
<hr />
<h4 id="definition-3"><a class="header" href="#definition-3">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  l = nixpkgs.lib // builtins;
in {
  configData = {};
  apply = d: let
    # Transforms interpreter attribute if present
    # nixpkgs.pkgname -&gt; nixpkgs.pkgname + '/bin/&lt;name&gt;'
    getExe = x: &quot;${l.getBin x}/bin/${x.meta.mainProgram or (l.getName x)}&quot;;
    final =
      d
      // {
        tasks =
          l.mapAttrs
          (n: v:
            v // l.optionalAttrs (v ? interpreter) {interpreter = getExe v.interpreter;})
          d.tasks;
      };
  in {
    data = final; # CUE expects structure to be wrapped with &quot;data&quot;
  };
  format = &quot;text&quot;;
  output = &quot;Justfile&quot;;
  packages = [nixpkgs.just];
  hook = {
    mode = &quot;copy&quot;;
  };
  engine = inputs.nixago.engines.cue {
    files = [./just.cue];
    flags = {
      expression = &quot;rendered&quot;;
      out = &quot;text&quot;;
    };
    postHook = ''
      ${l.getExe nixpkgs.just} --unstable --fmt -f $out
    '';
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lefthook"><a class="header" href="#lefthook"><a href="https://github.com/evilmartians/lefthook"><code>lefthook</code></a></a></h1>
<p>A fast (parallel execution) and elegant git hook manager.</p>
<hr />
<h4 id="definition-4"><a class="header" href="#definition-4">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  l = nixpkgs.lib // builtins;
in {
  configData = {};
  format = &quot;yaml&quot;;
  output = &quot;lefthook.yml&quot;;
  packages = [nixpkgs.lefthook];
  hook.extra = d: let
    # Add an extra hook for adding required stages whenever the file changes
    skip_attrs = [
      &quot;colors&quot;
      &quot;extends&quot;
      &quot;skip_output&quot;
      &quot;source_dir&quot;
      &quot;source_dir_local&quot;
    ];
    stages = l.attrNames (l.removeAttrs d skip_attrs);
    stagesStr = l.concatStringsSep &quot; &quot; stages;
  in ''
    # Install configured hooks
    for stage in ${stagesStr}; do
      ${l.getExe nixpkgs.lefthook} add -f &quot;$stage&quot;
    done
  '';
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook"><a class="header" href="#mdbook"><a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a></a></h1>
<p>Write clean docs for humans.</p>
<p>This version comes preset with this gem to make any
Solution Architect extra happy: <a href="https://github.com/joelcourtney/mdbook-kroki-preprocessor"><code>mdbook-kroki-preprocessor</code></a></p>
<hr />
<h4 id="definition-5"><a class="header" href="#definition-5">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
in {
  configData = {};
  output = &quot;book.toml&quot;;
  format = &quot;toml&quot;;
  hook.extra = d: let
    sentinel = &quot;nixago-auto-created: mdbook-build-folder&quot;;
    file = &quot;.gitignore&quot;;
    str = ''
      # ${sentinel}
      ${d.build.build-dir or &quot;book&quot;}/**
    '';
  in ''
    # Configure gitignore
    create() {
      echo -n &quot;${str}&quot; &gt; &quot;${file}&quot;
    }
    append() {
      echo -en &quot;\n${str}&quot; &gt;&gt; &quot;${file}&quot;
    }
    if ! test -f &quot;${file}&quot;; then
      create
    elif ! grep -qF &quot;${sentinel}&quot; &quot;${file}&quot;; then
      append
    fi
  '';
  commands = [{package = nixpkgs.mdbook;}];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="treefmt"><a class="header" href="#treefmt"><a href="https://github.com/numtide/treefmt"><code>treefmt</code></a></a></h1>
<p>A code formatter to fromat the entire code tree extremly fast (in parallel and with a smart cache).</p>
<hr />
<h4 id="definition-6"><a class="header" href="#definition-6">Definition:</a></h4>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
in {
  configData = {};
  output = &quot;treefmt.toml&quot;;
  format = &quot;toml&quot;;
  commands = [{package = nixpkgs.treefmt;}];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-error-message-functions"><a class="header" href="#standard-error-message-functions">Standard Error Message Functions</a></h1>
<p>This Cell Block comprises several error message functions that can be used in different situations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="removeby"><a class="header" href="#removeby"><code>removeBy</code></a></h1>
<pre><code class="language-nix">{inputs}: time: body: let
  l = inputs.nixpkgs.lib // builtins;
  pad = l.concatStringsSep &quot;&quot; (l.genList (_: &quot; &quot;) (21 - (l.stringLength time)));
in
  l.warn ''


    ===============================================
    !!!  🔥️  STANDARD DEPRECATION WARNING  🔥️   !!!
    -----------------------------------------------
    !!! Action required until scheduled removal !!!
    !!! Sheduled Removal: ${pad}${time} !!!
    -----------------------------------------------
    On schedule, deprecated facilities will be
    removed from Standard without further warning.
    -----------------------------------------------
    ${body}
    ===============================================

    ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳ ⏳



  ''
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requireinput"><a class="header" href="#requireinput"><code>requireInput</code></a></h1>
<pre><code class="language-nix">{inputs}: input: url: target: let
  l = inputs.nixpkgs.lib // builtins;

  # other than `divnix/blank`
  condition = inputs.${input}.sourceInfo.narHash != &quot;sha256-O8/MWsPBGhhyPoPLHZAuoZiiHo9q6FLlEeIDEXuj6T4=&quot;;

  trace = l.traceSeqN 1 inputs;
in
  assert l.assertMsg condition (trace ''

    ===============================================
    !!!  🚜️   STANDARD INPUT OVERLOADING   🚜️   !!!
    -----------------------------------------------
    In order to be able to use this target, an
    extra input must be overloaded onto Standard
    -----------------------------------------------
    Target:      ${target}
    Extra Input: ${input}
    Url:         ${url}
    -----------------------------------------------
    To fix this, add this to your './flake.nix':

      inputs.std.inputs.${input}.url =
        &quot;${url}&quot;;

    For reference, see current inputs to Standard
    in the above trace.
    ===============================================

    🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥 🔥



  ''); inputs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-standard-library"><a class="header" href="#the-standard-library">The Standard Library</a></h1>
<p>This library intends to cover the Software Delivery Life Cycle in the Standard way.</p>
<p>Each Cell Block covers a specific SDLC topic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-dev-library"><a class="header" href="#the-dev-library">The Dev Library</a></h1>
<p>This library covers <em>development</em> aspects of the SDLC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mkmakes-provides-an-interface-to-makes-tasks"><a class="header" href="#mkmakes-provides-an-interface-to-makes-tasks"><code>mkMakes</code> provides an interface to <code>makes</code> tasks</a></h1>
<p>This is an integration for <a href="https://github.com/fluidattacks/makes"><code>fluidattacks/makes</code></a>.</p>
<p>A version that has this <a href="https://github.com/fluidattacks/makes/commit/cd8c4eda69e2ce8dc6f811973ba0d80070b4628a">patch</a> is a prerequisite.</p>
<h2 id="usage-example-1"><a class="header" href="#usage-example-1">Usage example</a></h2>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs.std.lib) dev;
in {
  task = ops.mkMakes ./path/to/make/task//main.nix {};
}
</code></pre>
<p><em>Some refactoring of the tasks may be necessary. Let the error messages be your friend.</em></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="mkshell"><a class="header" href="#mkshell"><code>mkShell</code></a></h1>
<p>This is a transparent convenience proxy for <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code>’s</a> <code>mkShell</code> function.</p>
<p>It is enriched with a tight integration for <code>std</code> <a href="https://github.com/nix-community/nixago">Nixago</a> pebbles:</p>
<pre><code class="language-nix">{ inputs, cell}: {
  default = inputs.std.lib.dev.mkShell {
    /* ... */
    nixago = [
      (cell.nixago.foo {
        configData.qux = &quot;xyz&quot;;
        packages = [ pkgs.additional-package ];
      })
      cell.nixago.bar
      cell.nixago.quz
    ];
  };
}
</code></pre>
<p><em>Note, that you can extend any Nixago Pebble at the calling site
via a built-in functor like in the example above.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mknixago"><a class="header" href="#mknixago"><code>mkNixago</code></a></h1>
<p>This is a transparent convenience proxy for <a href="https://github.com/nix-community/nixago"><code>nix-community/nixago</code>’s</a> <code>lib.${system}.make</code> function.</p>
<p>It is enriched with a forward contract towards <code>std</code> enriched <code>mkShell</code> implementation.</p>
<p>In order to define <a href="https://github.com/numtide/devshell"><code>numtide/devshell</code>’s</a> <code>commands</code> &amp; <code>packages</code> alongside the Nixago pebble,
just add the following attrset to the Nixago spec. It will be picked up automatically by <code>mkShell</code> when that pebble
is used inside its <code>config.nixago</code>-option.</p>
<pre><code class="language-nix">{ inputs, cell }: {
  foo = inputs.std.lib.dev.mkNixago {
    /* ... */
    packages = [ /* ... */ ];
    commands = [ /* ... */ ];
    devshell = { /* ... */ }; # e.g. for startup hooks
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-ops-library"><a class="header" href="#the-ops-library">The Ops Library</a></h1>
<p>This library covers <em>operational</em> aspects of the SDLC.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mkmicrovm-provides-an-interface-to-microvm-tasks"><a class="header" href="#mkmicrovm-provides-an-interface-to-microvm-tasks"><code>mkMicrovm</code> provides an interface to <code>microvm</code> tasks</a></h1>
<p>This is an integration for <a href="https://github.com/astro/microvm.nix"><code>astro/microvm.nix</code></a>.</p>
<h2 id="usage-example-2"><a class="header" href="#usage-example-2">Usage example</a></h2>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs.std.lib) ops;
in {
  # microvm &lt;module&gt;
  myhost = ops.mkMicrovm ({ pkgs, lib, ... }: { networking.hostName = &quot;microvms-host&quot;;});
}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="mkoperable"><a class="header" href="#mkoperable"><code>mkOperable</code></a></h1>
<p>… is a function interface into the <a href="reference/lib/ops//patterns/four-packaging-layers.html#operable-layer">second layer of packaging</a> of the Standard SDLC Packaging pattern.</p>
<p>It’s purpose is to provide an easy way to enrich a “package” into an “operable”.</p>
<p>The function signature is as follows:</p>
<pre><code class="language-nix">  /*
  Makes a package operable by configuring the necessary runtime environment.

  Args:
  package: The package to wrap.
  runtimeScript: A bash script to run at runtime.
  runtimeEnv: An attribute set of environment variables to set at runtime.
  runtimeInputs: A list of packages to add to the runtime environment.
  livenessProbe: An optional derivation to run to check if the program is alive.
  readinessProbe: An optional derivation to run to check if the program is ready.

  Returns:
  An operable for the given package.
  */
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mkoci"><a class="header" href="#mkoci"><code>mkOCI</code></a></h1>
<p>… is a function to generate an OCI Image via <a href="https://github.com/nlewo/nix2container"><code>nix2container</code></a>.</p>
<p>The function signature is as follows:</p>
<pre><code class="language-nix">  /*
  Creates an OCI container image

  Args:
  name: The name of the image.
  entrypoint: The entrypoint of the image. Must be a derivation.
  tag: Optional tag of the image (defaults to output hash)
  setup: A list of setup tasks to run to configure the container.
  uid: The user ID to run the container as.
  gid: The group ID to run the container as.
  perms: A list of permissions to set for the container.
  labels: An attribute set of labels to set for the container. The keys are
  automatically prefixed with &quot;org.opencontainers.image&quot;.
  options: Additional options to pass to nix2container.buildImage.

  Returns:
  An OCI container image (created with nix2container).
  */
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mkstandardoci"><a class="header" href="#mkstandardoci"><code>mkStandardOCI</code></a></h1>
<p>… is a function interface into the <a href="reference/lib/ops//patterns/four-packaging-layers.html#oci-image-layer">third layer of packaging</a> of the Standard SDLC Packaging pattern.</p>
<p>It produces a Standard OCI Image from an <a href="reference/lib/ops/./mkOperable.html">“operable”</a>.</p>
<p>The function signature is as follows:</p>
<pre><code class="language-nix">  /*
  Creates an OCI container image using the given operable.

  Args:
  name: The name of the image.
  operable: The operable to wrap in the image.
  tag: Optional tag of the image (defaults to output hash)
  setup: A list of setup tasks to run to configure the container.
  uid: The user ID to run the container as.
  gid: The group ID to run the container as.
  perms: A list of permissions to set for the container.
  labels: An attribute set of labels to set for the container. The keys are
  automatically prefixed with &quot;org.opencontainers.image&quot;.
  debug: Whether to include debug tools in the container (coreutils).
  options: Additional options to pass to nix2container.

  Returns:
  An OCI container image (created with nix2container).
  */
</code></pre>
<h2 id="the-standard-image"><a class="header" href="#the-standard-image">The Standard Image</a></h2>
<p>Standard images are minimal and hardened. They only contain required dependencies.</p>
<h3 id="contracts"><a class="header" href="#contracts">Contracts</a></h3>
<p>The following contracts can be consumed:</p>
<pre><code>/bin/entrypoint # always present
/bin/runtime    # always present, drops into the runtime environment
/bin/live       # if livenessProbe was set
/bin/ready      # if readinessProbe was set
</code></pre>
<p>That’s it. There is nothing more to see.</p>
<p>All other dependencies are contained in <code>/nix/store/...</code>.</p>
<h2 id="the-debug-image"><a class="header" href="#the-debug-image">The Debug Image</a></h2>
<p>Debug Images wrap the standard images and provide additional debugging packages.</p>
<p>Hence, they are neither minimal, nor hardened because of the debugging packages’ added surface.</p>
<h3 id="contracts-1"><a class="header" href="#contracts-1">Contracts</a></h3>
<p>The following contracts can be consumed:</p>
<pre><code>/bin/entrypoint # always present
/bin/runtime    # always present, drops into the runtime environment
/bin/debug      # always present, drops into the debugging environment
/bin/live       # if livenessProbe was set
/bin/ready      # if readinessProbe was set
</code></pre>
<h2 id="how-to-extend"><a class="header" href="#how-to-extend">How to extend?</a></h2>
<p>A Standard or Debug Image doesn’t have a package manager available in the environment.</p>
<p>Hence, to extend the image you have two options:</p>
<h3 id="nix-based-extension"><a class="header" href="#nix-based-extension">Nix-based extension</a></h3>
<pre><code class="language-nix">rec {
  upstream = n2c.pullImage {
    imageName = &quot;docker.io/my-upstream-image&quot;;
    imageDigest = &quot;sha256:fffff.....&quot;;
    sha256 = &quot;sha256-ffffff...&quot;;
  };
  modified = n2c.buildImage {
    name = &quot;docker.io/my-modified-image&quot;;
    fromImage = upstream;
    contents = [nixpkgs.bashInteractive];
  };
}
</code></pre>
<h3 id="dockerfile-based-extension"><a class="header" href="#dockerfile-based-extension">Dockerfile-based extension</a></h3>
<pre><code class="language-Dockerfile">FROM alpine AS builder
RUN apk --no-cache curl

FROM docker.io/my-upstream-image
COPY --from=builder /... /

</code></pre>
<p><em>Please refer to the official dockerfile documentation for more details.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-presets"><a class="header" href="#standard-presets">Standard Presets</a></h1>
<p>Standard Presets bring out-of-the-box experiences.
Though, by being clearly marked as “presets”, you can ignore them as you please.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nix-templates"><a class="header" href="#nix-templates">Nix Templates</a></h1>
<p>These are opinionated template projects designed to get you kick-started.</p>
<p>You can make use of them through the Nix CLI, via:</p>
<pre><code class="language-console">$ cd my-new-project
$ nix flake init -t github:divnix/std#&lt;template-name&gt;
</code></pre>
<p>Please consult the template section in the <a href="https://std.divnix.com/">docs</a> for an overview.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nixago-presets"><a class="header" href="#nixago-presets">Nixago Presets</a></h1>
<p>These are out-of-the-box configurations of Nixago Pebbles.</p>
<p>You can amend them the same way they, themeselves, amend the base Nixago Pebbles:</p>
<pre><code class="language-nix">{
  inputs,
  cell,
}: let
  inherit (inputs) nixpkgs;
  inherit (inputs.cells) std;
  l = nixpkgs.lib // builtins;
in {
  adrgen = std.nixago.adrgen {
    configData = import ./nixago/adrgen.nix;
  };
  editorconfig = std.nixago.editorconfig {
    configData = import ./nixago/editorconfig.nix;
    hook.mode = &quot;copy&quot;; # already useful before entering the devshell
  };
  conform = std.nixago.conform {
    configData = import ./nixago/conform.nix;
  };
  lefthook = std.nixago.lefthook {
    configData = import ./nixago/lefthook.nix;
  };
  mdbook = std.nixago.mdbook {
    configData = import ./nixago/mdbook.nix;
    hook.mode = &quot;copy&quot;; # let CI pick it up outside of devshell
    packages = [std.packages.mdbook-kroki-preprocessor];
  };
  treefmt = std.nixago.treefmt {
    configData = import ./nixago/treefmt.nix;
    packages = [
      nixpkgs.alejandra
      nixpkgs.nodePackages.prettier
      nixpkgs.nodePackages.prettier-plugin-toml
      nixpkgs.shfmt
    ];
    devshell.startup.prettier-plugin-toml = l.stringsWithDeps.noDepEntry ''
      export NODE_PATH=${nixpkgs.nodePackages.prettier-plugin-toml}/lib/node_modules:$NODE_PATH
    '';
  };
}
</code></pre>
<p><code>just</code> doesn’t have a preset: for a task runner, it wouldn’t make a lot of sense.</p>
<p><em>If you have a good idea how to make these presets more useful, please consider to submit a PR.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adrgen-nixago-presets"><a class="header" href="#adrgen-nixago-presets"><code>adrgen</code> Nixago Presets</a></h1>
<pre><code class="language-nix">{
  default_meta = [];
  default_status = &quot;proposed&quot;;
  directory = &quot;docs/explain/architecture-decision-records&quot;;
  id_digit_number = 4;
  supported_statuses = [
    &quot;proposed&quot;
    &quot;accepted&quot;
    &quot;rejected&quot;
    &quot;superseded&quot;
    &quot;amended&quot;
    &quot;deprecated&quot;
  ];
  template_file = &quot;docs/explain/architecture-decision-records/template.md&quot;;
}
</code></pre>
<p><em>If you have a good idea how to make these presets more useful, please consider to submit a PR.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conform-nixago-presets"><a class="header" href="#conform-nixago-presets"><code>conform</code> Nixago Presets</a></h1>
<pre><code class="language-nix">{
  commit = {
    header = {length = 89;};
    conventional = {
      types = [
        &quot;build&quot;
        &quot;chore&quot;
        &quot;ci&quot;
        &quot;docs&quot;
        &quot;feat&quot;
        &quot;fix&quot;
        &quot;perf&quot;
        &quot;refactor&quot;
        &quot;style&quot;
        &quot;test&quot;
      ];
      scopes = [];
    };
  };
}
</code></pre>
<p><em>If you have a good idea how to make these presets more useful, please consider to submit a PR.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editorconfig-nixago-presets"><a class="header" href="#editorconfig-nixago-presets"><code>editorconfig</code> Nixago Presets</a></h1>
<pre><code class="language-nix">{
  # root = true;

  &quot;*&quot; = {
    end_of_line = &quot;lf&quot;;
    insert_final_newline = true;
    trim_trailing_whitespace = true;
    charset = &quot;utf-8&quot;;
    indent_style = &quot;space&quot;;
    indent_size = 2;
  };

  &quot;*.{diff,patch}&quot; = {
    end_of_line = &quot;unset&quot;;
    insert_final_newline = &quot;unset&quot;;
    trim_trailing_whitespace = &quot;unset&quot;;
    indent_size = &quot;unset&quot;;
  };

  &quot;*.md&quot; = {
    max_line_length = &quot;off&quot;;
    trim_trailing_whitespace = false;
  };
  &quot;{LICENSES/**,LICENSE}&quot; = {
    end_of_line = &quot;unset&quot;;
    insert_final_newline = &quot;unset&quot;;
    trim_trailing_whitespace = &quot;unset&quot;;
    charset = &quot;unset&quot;;
    indent_style = &quot;unset&quot;;
    indent_size = &quot;unset&quot;;
  };
}
</code></pre>
<p><em>If you have a good idea how to make these presets more useful, please consider to submit a PR.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lefthook-nixago-presets"><a class="header" href="#lefthook-nixago-presets"><code>lefthook</code> Nixago Presets</a></h1>
<pre><code class="language-nix">{
  commit-msg = {
    commands = {
      conform = {
        run = &quot;conform enforce --commit-msg-file {1}&quot;;
        skip = [&quot;merge&quot; &quot;rebase&quot;];
      };
    };
  };
  pre-commit = {
    commands = {
      treefmt = {
        run = &quot;treefmt {staged_files}&quot;;
        glob = &quot;*&quot;;
        skip = [&quot;merge&quot; &quot;rebase&quot;];
      };
    };
  };
}
</code></pre>
<p><em>If you have a good idea how to make these presets more useful, please consider to submit a PR.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook-nixago-presets"><a class="header" href="#mdbook-nixago-presets"><code>mdbook</code> Nixago Presets</a></h1>
<pre><code class="language-nix">{
  book = {
    language = &quot;en&quot;;
    multilingual = false;
    src = &quot;docs&quot;;
    title = &quot;Documentation&quot;;
  };
  build = {
    build-dir = &quot;docs/book&quot;;
  };
  preprocessor = {
    kroki-preprocessor = {
      command = &quot;mdbook-kroki-preprocessor&quot;;
    };
  };
}
</code></pre>
<p><em>If you have a good idea how to make these presets more useful, please consider to submit a PR.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="treefmt-nixago-presets"><a class="header" href="#treefmt-nixago-presets"><code>treefmt</code> Nixago Presets</a></h1>
<pre><code class="language-nix">{
  formatter = {
    nix = {
      command = &quot;alejandra&quot;;
      includes = [&quot;*.nix&quot;];
    };
    prettier = {
      command = &quot;prettier&quot;;
      options = [&quot;--plugin&quot; &quot;prettier-plugin-toml&quot; &quot;--write&quot;];
      includes = [
        &quot;*.css&quot;
        &quot;*.html&quot;
        &quot;*.js&quot;
        &quot;*.json&quot;
        &quot;*.jsx&quot;
        &quot;*.md&quot;
        &quot;*.mdx&quot;
        &quot;*.scss&quot;
        &quot;*.ts&quot;
        &quot;*.yaml&quot;
        &quot;*.toml&quot;
      ];
    };
    shell = {
      command = &quot;shfmt&quot;;
      options = [&quot;-i&quot; &quot;2&quot; &quot;-s&quot; &quot;-w&quot;];
      includes = [&quot;*.sh&quot;];
    };
  };
}
</code></pre>
<p><em>If you have a good idea how to make these presets more useful, please consider to submit a PR.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devshells-1"><a class="header" href="#devshells-1">Devshells</a></h1>
<ul>
<li>The <code>default</code> devshell implements the development environment for the <code>std</code> TUI/CLI.</li>
<li>Furthermore, it implements a <code>pre-commit</code> hook to keep the source code formatted.</li>
<li>It makes use of <code>std.lib.mkShell</code> which is a convenience proxy for <code>numtide/devshell</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p><strong>Cell</strong></p>
<p>: A Cell is the folder name of the first level under <code>${cellsFrom}</code>. They represent a coherent semantic collection of functionality.</p>
<p><strong>Cell Block</strong></p>
<p>: A Cell Block is the specific <em>named type</em> of a Standard (and hence: Flake) output.</p>
<p><strong>Block Type</strong></p>
<p>: A Block Type is the unnamed generic type of a Cell Block and may or may not implement Block Type Actions.</p>
<p><strong>Target</strong></p>
<p>: A Target is the actual output of a Cell Block. If there is only one intended output, it is called <code>default</code> by convention.</p>
<p><strong>Action</strong></p>
<p>: An Action is a runnable procedure implemented on the generic Block Type type. These are abstract procedures that are valuable in any concrete Cell Block of such Block Type.</p>
<p><strong>The Registry</strong></p>
<p>: The Registry, in the context of Standard and if it doesn’t refer to a well-known external concept, means the <code>.#__std</code> flake output. This Registry holds different Registers that serve different discovery purposes. For example, the CLI can discover relevant metadata or a CI can discover desired pipeline targets.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="static/mermaid.min.js"></script>
        <script type="text/javascript" src="static/mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
